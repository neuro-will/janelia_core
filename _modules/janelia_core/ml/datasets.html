<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>janelia_core.ml.datasets &mdash; janelia_core 1.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> janelia_core
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Setting up the core library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html#dependencies">Dependencies</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/janelia_core/index.html">janelia_core</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">janelia_core</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>janelia_core.ml.datasets</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for janelia_core.ml.datasets</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Tools for representing and working with Pytorch datasets. &quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.utils.data</span>


<div class="viewcode-block" id="TimeSeriesBatch"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesBatch">[docs]</a><span class="k">class</span> <span class="nc">TimeSeriesBatch</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; An object to represent a batch of samples from time series data.</span>

<span class="sd">    Each sample in the batch is a pair consisting of data at time t-1 and data at time t.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">i_x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">i_y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">i_orig</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            data: data[i] contains data for the i^th group of variables.  Dimension 0 indexes individual points.</span>

<span class="sd">            i_x: Indicates which points in data correspond to the t-1 data points in each sample.</span>

<span class="sd">            i_y: Indicates which points in data correspond to the t data points in each sample.</span>

<span class="sd">            i_orig: Indicates the original indices in the larger TimeSeriesData object the data points came from.</span>
<span class="sd">            (Keeping track of this is helpful when needing to merge and concatenate batches later.)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_x</span> <span class="o">=</span> <span class="n">i_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_y</span> <span class="o">=</span> <span class="n">i_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span> <span class="o">=</span> <span class="n">i_orig</span>

<div class="viewcode-block" id="TimeSeriesBatch.pin_memory"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesBatch.pin_memory">[docs]</a>    <span class="k">def</span> <span class="nf">pin_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Puts this object&#39;s data into pinned memory. &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pin_memory</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">i_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_x</span><span class="o">.</span><span class="n">pin_memory</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_y</span><span class="o">.</span><span class="n">pin_memory</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span><span class="o">.</span><span class="n">pin_memory</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="TimeSeriesBatch.to"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesBatch.to">[docs]</a>    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">move_i_orig</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">non_blocking</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Moves data to the specified device.</span>

<span class="sd">        Args:</span>
<span class="sd">            device: The device to move the data to.</span>

<span class="sd">            move_i_orig: If true, i_orig will be moved to the device.  If false, only data, i_x and i_y will be</span>
<span class="sd">            moved to the device.</span>

<span class="sd">            non_blocking: If the .to() command should be passed the non_blocking option.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="n">non_blocking</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="n">non_blocking</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_y</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="n">non_blocking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">move_i_orig</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="n">non_blocking</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesBatch.__len__"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesBatch.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Returns the number of samples in the dataset. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i_x</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesBatch.__getitem__"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesBatch.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns requested samples from the dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            index: Integer index, slice or numpy array indicating requested samples.</span>
<span class="sd">            The index is specifically into the i_x and i_y attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            smps: The requested samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get unique list of i_orig values for the samples we are to keep</span>
        <span class="n">keep_i_orig_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i_x</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">keep_i_orig_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i_y</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">keep_i_orig_x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">keep_i_orig_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">keep_i_orig_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keep_i_orig_y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">keep_i_orig_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">keep_i_orig_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">keep_i_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">keep_i_orig_x</span><span class="p">,</span> <span class="n">keep_i_orig_y</span><span class="p">)))</span>

        <span class="c1"># Find out where the i_orig values that we are keeping come from in the original data array</span>
        <span class="n">pull_inds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span> <span class="o">==</span> <span class="n">ind</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">keep_i_orig</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Pull the values for the new data and i_orig</span>
        <span class="n">pulled_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">pull_inds</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="n">pulled_i_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span><span class="p">[</span><span class="n">pull_inds</span><span class="p">]</span>

        <span class="c1"># Form the new i_x and i_y</span>
        <span class="n">pulled_i_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">pulled_i_orig</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_i_orig_x</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="n">pulled_i_y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">pulled_i_orig</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_i_orig_y</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">TimeSeriesBatch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">pulled_data</span><span class="p">,</span> <span class="n">i_x</span><span class="o">=</span><span class="n">pulled_i_x</span><span class="p">,</span> <span class="n">i_y</span><span class="o">=</span><span class="n">pulled_i_y</span><span class="p">,</span> <span class="n">i_orig</span><span class="o">=</span><span class="n">pulled_i_orig</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeriesBatch.efficient_get_item"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesBatch.efficient_get_item">[docs]</a>    <span class="k">def</span> <span class="nf">efficient_get_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A computational (but not memory) efficient way of indexing a TimeSeriesBatch object.</span>

<span class="sd">        A new TimeSeriesBatch object will be returned with unmodified data and i_orig attributes.  The i_x</span>
<span class="sd">        and i_y attributes will be updated to index the data and i_orig attributes.  By not discarding</span>
<span class="sd">        any unused points in the data attribute, indexing can be done very quickly.</span>

<span class="sd">        This function can be useful when seeking to index an existing TimeSeriesBatch object when we will not</span>
<span class="sd">        need to copy the result to another place in memory (e.g., sending to a GPU when the indexed TimeSeriesBatch</span>
<span class="sd">        object is on CPU).</span>

<span class="sd">        Args:</span>
<span class="sd">            index: Integer index, slice or numpy array indicating requested samples.</span>
<span class="sd">            The index is specifically into the i_x and i_y attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            smps: The requested samples in a TimeSeriesBatch object as described above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="n">index</span><span class="p">])</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">TimeSeriesBatch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i_x</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">i_y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i_y</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">i_orig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i_orig</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TimeSeriesDataset"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesDataset">[docs]</a><span class="k">class</span> <span class="nc">TimeSeriesDataset</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Extends torch&#39;s Dataset object specifically for time series data.</span>

<span class="sd">    This object is specifically designed for scenarios when we want to predict points at time t + 1 from points at</span>
<span class="sd">    time t.</span>

<span class="sd">    The user supplies the time series data for different groups of variables.  He or she can then request samples, which</span>
<span class="sd">    will return the time series data for the samples. Each sampled data point is a pair corresponding to data at</span>
<span class="sd">    time t and the data a time t + 1.  Therefore, a dataset with T time points will contain T-1 samples.</span>

<span class="sd">    The requested samples will be returned in a memory efficient manner to avoid representing duplicate points</span>
<span class="sd">    twice.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts_data</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot; Creates a TimeSeriesDataset object.</span>

<span class="sd">        Args:</span>
<span class="sd">            ts_data: Time series data. ts_data[i] is time series data for the i^th group of variables.  Time is</span>
<span class="sd">            represented along dimension 0.  All ts_data tensors must have the same number of time points.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If not all ts_data tensors have the same number of time points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="n">n_ts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">ts_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ts_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">)]):</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All tensors in ts_data must have same number of time points.&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ts_data</span> <span class="o">=</span> <span class="n">ts_data</span>

<div class="viewcode-block" id="TimeSeriesDataset.__len__"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesDataset.__len__">[docs]</a>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Returns the number of samples in the dataset.</span>

<span class="sd">        Note that number of samples in the dataset is 1 less than the number of time points, as samples</span>
<span class="sd">        consist of pairs of data points at time t-1 and time t.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The number of samples in the dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="TimeSeriesDataset.__getitem__"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.TimeSeriesDataset.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TimeSeriesBatch</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Returns requested samples from the dataset.</span>

<span class="sd">        A single sample consists of a pair of data points at time t-1 and at time t.</span>

<span class="sd">        Args:</span>
<span class="sd">            index: Integer index or slice indicating requested samples.</span>

<span class="sd">        Returns:</span>
<span class="sd">            smps: The requested samples.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># Determine indices into the dataset for all points in the pairs</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">x_indices</span> <span class="o">=</span> <span class="n">all_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="c1"># Indices for points in each sample at time t</span>
        <span class="n">y_indices</span> <span class="o">=</span> <span class="n">x_indices</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Indices for points in each sample at time t + 1</span>
        <span class="n">union_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x_indices</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y_indices</span><span class="p">))))</span>

        <span class="c1"># Ensure indices are sorted</span>
        <span class="n">union_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">union_indices</span><span class="p">)</span>

        <span class="c1"># Form x_idx &amp; y_idx</span>
        <span class="n">x_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">union_indices</span> <span class="o">==</span> <span class="n">x_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x_i</span> <span class="ow">in</span> <span class="n">x_indices</span><span class="p">])</span>
        <span class="n">y_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">union_indices</span> <span class="o">==</span> <span class="n">y_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">y_i</span> <span class="ow">in</span> <span class="n">y_indices</span><span class="p">])</span>
        <span class="n">x_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">x_idx</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="n">y_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">y_idx</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Form output</span>
        <span class="n">union_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">union_indices</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">TimeSeriesBatch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">tensor</span><span class="p">[</span><span class="n">union_indices</span><span class="p">]</span> <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts_data</span><span class="p">],</span>
                               <span class="n">i_x</span><span class="o">=</span><span class="n">x_idx</span><span class="p">,</span>
                               <span class="n">i_y</span><span class="o">=</span><span class="n">y_idx</span><span class="p">,</span>
                               <span class="n">i_orig</span><span class="o">=</span><span class="n">union_indices</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="cat_time_series_batches"><a class="viewcode-back" href="../../../autoapi/janelia_core/ml/datasets/index.html#janelia_core.ml.datasets.cat_time_series_batches">[docs]</a><span class="k">def</span> <span class="nf">cat_time_series_batches</span><span class="p">(</span><span class="n">batches</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TimeSeriesBatch</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TimeSeriesBatch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Concatenates multiple TimeSeriesBatches into one object in a memory efficient manner.</span>
<span class="sd">    </span>
<span class="sd">    The i_x and i_y fields of the new TimeSeriesBatch object will effectively be concatenations of the</span>
<span class="sd">    i_x and i_y fields from the original, individual TimeSeriesBatch objects, though the values of i_x and</span>
<span class="sd">    i_y may be changed to appropriately index into the data tensors of the returned TimeSeriesBatch object.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        batch: A list of TimeSeriesBatch objects to concatenate.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        conc_batch: The TimeSeriesBatch object representing the concatenated result.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ===============================================================</span>
    <span class="c1"># Merge the data of all batches</span>
    <span class="n">n_grps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># Construct a lookup table</span>
    <span class="n">lut</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">i_orig</span><span class="p">,</span> <span class="c1"># Original indices each data point came from</span>
                                  <span class="n">b_i</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">i_orig</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">(),</span> <span class="c1"># Batch each data point came from</span>
                                  <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">i_orig</span><span class="p">))</span> <span class="c1"># Position in each batch of each sample</span>
                                      <span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batches</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Determine what the unique sample time points are and make sure they are sorted</span>
    <span class="n">cat_i_orig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lut</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">lut_rows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">lut</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">u_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">u_i</span> <span class="ow">in</span> <span class="n">cat_i_orig</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

    <span class="c1"># Now form the merged data for each group</span>
    <span class="n">cat_data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_grps</span>
    <span class="k">for</span> <span class="n">g_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_grps</span><span class="p">):</span>
        <span class="n">cat_data</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">batches</span><span class="p">[</span><span class="n">lut</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">g_i</span><span class="p">][</span><span class="n">lut</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">lut_rows</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Now form the merged i_x and i_y</span>
    <span class="n">i_x_orig_inds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">i_orig</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">i_x</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">))</span>
    <span class="n">i_y_orig_inds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">i_orig</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">i_y</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">))</span>

    <span class="n">cat_i_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">cat_i_orig</span> <span class="o">==</span> <span class="n">i_o</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_o</span> <span class="ow">in</span> <span class="n">i_x_orig_inds</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
    <span class="n">cat_i_y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">cat_i_orig</span> <span class="o">==</span> <span class="n">i_o</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i_o</span> <span class="ow">in</span> <span class="n">i_y_orig_inds</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

    <span class="c1"># Now form merged TimeSeriesBatch object</span>
    <span class="k">return</span> <span class="n">TimeSeriesBatch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">cat_data</span><span class="p">,</span> <span class="n">i_x</span><span class="o">=</span><span class="n">cat_i_x</span><span class="p">,</span> <span class="n">i_y</span><span class="o">=</span><span class="n">cat_i_y</span><span class="p">,</span> <span class="n">i_orig</span><span class="o">=</span><span class="n">cat_i_orig</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, William Bishop.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>