<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>janelia_core.ml.latent_regression.scenarios &mdash; janelia_core 1.0 documentation</title><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> janelia_core
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Setting up the core library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html#dependencies">Dependencies</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../autoapi/janelia_core/index.html">janelia_core</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">janelia_core</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>janelia_core.ml.latent_regression.scenarios</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for janelia_core.ml.latent_regression.scenarios</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Tools for generating simulated latent regression models. &quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">janelia_core.ml.datasets</span> <span class="kn">import</span> <span class="n">TimeSeriesDataset</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.extra_torch_modules</span> <span class="kn">import</span> <span class="n">FixedOffsetExp</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.extra_torch_modules</span> <span class="kn">import</span> <span class="n">IndSmpConstantBoundedFcn</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.extra_torch_modules</span> <span class="kn">import</span> <span class="n">IndSmpConstantRealFcn</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.extra_torch_modules</span> <span class="kn">import</span> <span class="n">SumOfTiledHyperCubeBasisFcns</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.latent_regression.group_maps</span> <span class="kn">import</span> <span class="n">ConcatenateMap</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.latent_regression.group_maps</span> <span class="kn">import</span> <span class="n">IdentityMap</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.latent_regression.subject_models</span> <span class="kn">import</span> <span class="n">LatentRegModel</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.latent_regression.vi</span> <span class="kn">import</span> <span class="n">SubjectVICollection</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.torch_distributions</span> <span class="kn">import</span> <span class="n">CondGaussianDistribution</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.torch_distributions</span> <span class="kn">import</span> <span class="n">CondMatrixProductDistribution</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.torch_distributions</span> <span class="kn">import</span> <span class="n">GroupCondMatrixHypercubePrior</span>
<span class="kn">from</span> <span class="nn">janelia_core.ml.utils</span> <span class="kn">import</span> <span class="n">torch_mod_to_fcn</span>
<span class="kn">from</span> <span class="nn">janelia_core.visualization.image_generation</span> <span class="kn">import</span> <span class="n">generate_image_from_fcn</span>


<div class="viewcode-block" id="GaussianBumpFcn"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.GaussianBumpFcn">[docs]</a><span class="k">class</span> <span class="nc">GaussianBumpFcn</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A Gaussian bump function with fixed parameters.</span>

<span class="sd">     The bump function will be axis-aligned but can have different standard deviations along each axis.</span>
<span class="sd">     &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctr</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">std</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">peak_vl</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new GaussianBump module.</span>

<span class="sd">        Args:</span>
<span class="sd">            ctr: A 1-d tensor giving the center location of the bump.</span>

<span class="sd">            std: A 1-d tensor giving the standard deviation of the bump along each axis.</span>

<span class="sd">            peak_vl: The value at the peak of the bump.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ctr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">ctr</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_vl</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="n">peak_vl</span><span class="p">]),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="GaussianBumpFcn.forward"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.GaussianBumpFcn.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes input from output.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Input.  Each row is a sample.</span>

<span class="sd">        Returns:</span>
<span class="sd">            y: Output.  Each row corresponds to a transformed input sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_smps</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">x_ctr</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctr</span>
        <span class="n">x_ctr_scaled</span> <span class="o">=</span> <span class="n">x_ctr</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_ctr_scaled</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x_dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_ctr_scaled</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_dist</span> <span class="o">=</span> <span class="n">x_ctr_scaled</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_vl</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">x_dist</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">n_smps</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="ConstantFcn"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.ConstantFcn">[docs]</a><span class="k">class</span> <span class="nc">ConstantFcn</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Represents a function which is constant everywhere with fixed parameters. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a ConstantFcn object.</span>

<span class="sd">        Args:</span>
<span class="sd">            c: Constant value of function.  A 1-d array with length equal to dimensionality of output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<div class="viewcode-block" id="ConstantFcn.forward"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.ConstantFcn.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Computes output from input.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Input of shape n_smps*d_x</span>

<span class="sd">            y: Output of shape n_smps*d_y.  (Each row will be equal to the constant value of the function.)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_smps</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">n_smps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IdentityS"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.IdentityS">[docs]</a><span class="k">class</span> <span class="nc">IdentityS</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Module which just passes through input. &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IdentityS.forward"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.IdentityS.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span></div></div>




<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario">[docs]</a><span class="k">class</span> <span class="nc">BumpInputWithRecursiveDynamicsScenario</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Objects for generating models and data where we record neurons from multiple subjects receiving stimuli.</span>

<span class="sd">    We simulate recording neural activity from multiple subjects while they are presented stimuli.  There are a set of</span>
<span class="sd">    inputs that drive different patterns of activity across the population.  Activity across the population is then read</span>
<span class="sd">    out and in turn drive other sets of patterns (internal dynamics).</span>

<span class="sd">    Neurons are characterized by their position in a unit hypercube (number of dimensions is user set).</span>

<span class="sd">    The patterns of activity that is driven be each stimulus are determined by the loadings of a set of modes, one mode</span>
<span class="sd">    for each stimulus.  The loadings for neurons for each mode is a probabilistic function of their position.</span>
<span class="sd">    Specifically, we select loadings for modes for each subject from bump shaped priors.  Similarly, the modes which</span>
<span class="sd">    determine the internal dynamics of the population also come from bump shaped priors.</span>

<span class="sd">    By &quot;bump shaped prior&quot; we mean that the conditional distribution for a neuron&#39;s loading in a particular mode</span>
<span class="sd">    given it&#39;s position in space is Gaussian with a conditional mean which is shaped like a bump in space. In this</span>
<span class="sd">    simple scenario, we assume the standard deviation of the conditional distributions is the same irrespective of a</span>
<span class="sd">    neuron&#39;s location in space.</span>

<span class="sd">    We select the p modes of the internal dynamics to be roughly aligned with the u modes of the stimuli, to ensure</span>
<span class="sd">    that stimulus activity is propagated into the internal dynamics of the population.</span>

<span class="sd">    The logic for using this object is as follows:</span>

<span class="sd">        1) Initialize a scenario - this creates the priors and the subject models</span>

<span class="sd">        2) Simulate data for the scenario using the generate_data function</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_subjects</span><span class="p">,</span> <span class="n">n_modes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_neuron_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">prior_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">02</span><span class="p">,</span>
                 <span class="n">bump_max_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">09</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">],</span> <span class="n">bump_std_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">],</span>
                 <span class="n">noise_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">],</span> <span class="n">n_dims</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pos_neg_modes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">input_bump_ctrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">input_bump_stds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">input_bump_gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">int_bump_ctrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">int_bump_stds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">int_bump_gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; Creates a new BumpInputWithRecursiveDynamicsScenario object.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_subjects: The number of subject models to generate.</span>

<span class="sd">            n_modes: The number of modes each model should have.  There will be 2*n_modes p and u modes per subject.</span>

<span class="sd">            n_neuron_range: The number of neurons each subject has will be pulled uniformly from this range.</span>

<span class="sd">            prior_std: The standard deviation of each prior conditional distribution.</span>

<span class="sd">            bump_gain_range: We use a Gaussian kernel for the bump functions which form the conditional means for each</span>
<span class="sd">            mode. Each bump has a randomly chosen peak value magnitude.  These peak values are pulled uniformly from the</span>
<span class="sd">            interval specified by bump_gain_range. See pos_neg_modes below about how the signs of these peaks are</span>
<span class="sd">            chosen.</span>

<span class="sd">            bump_std_range: The Gaussian kernel functions for the conditional means will be axis aligned with a certain</span>
<span class="sd">            standard deviation along each axis.  The standard deviation values along each axis will be pulled uniformly</span>
<span class="sd">            from this range.</span>

<span class="sd">            noise_range: Range of values to pull psi values from when generating latent regression models</span>

<span class="sd">            n_dims: The number of spatial dimensions neurons are arranged in.</span>

<span class="sd">            pos_neg_modes: If true, the sign of the peak of modes can be either positive or negative (with 50%</span>
<span class="sd">            probability)</span>

<span class="sd">            input_bump_ctrs: If not None, the parameters of the bump function forming the means for the input mode</span>
<span class="sd">            couplings (and internal p couplings) will not be randomly generated but will instead be specified by the</span>
<span class="sd">            user.  input_bump_ctrs[:, i] gives the center for the bump function for the i^th mode.</span>

<span class="sd">            input_bump_stds: If not randomly generating parameters for the input mean functions, input_bump_stds[:, i]</span>
<span class="sd">            gives the dimension standard deviations for the i^th mode.</span>

<span class="sd">            input_bump_gains: If not randomly generating parameters for the input mean functions, input_bump_gains[i]</span>
<span class="sd">            gives the gain for the i^th mode.</span>

<span class="sd">            int_bump_ctrs, int_bump_stds, int_bump_gains: Analagous to the same for the input modes but specifying the</span>
<span class="sd">            parameters of the mean functions for the internal u modes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">use_fixed_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_bump_ctrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">int_bump_ctrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Generate the prior distribution for the input &amp; internal u modes</span>
        <span class="n">bump_gain_int_width</span> <span class="o">=</span> <span class="n">bump_max_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bump_max_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bump_std_int_width</span> <span class="o">=</span> <span class="n">bump_std_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bump_std_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">inp_int_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">u_modes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_modes</span>
            <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="p">):</span>

                <span class="c1"># Create the conditional mean bump function</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">use_fixed_params</span><span class="p">[</span><span class="n">inp_int_i</span><span class="p">]:</span>
                    <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bump_gain_int_width</span> <span class="o">+</span> <span class="n">bump_max_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">pos_neg_modes</span><span class="p">:</span>
                        <span class="n">sign</span>  <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">gain</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="n">gain</span>
                    <span class="n">dim_stds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)</span><span class="o">*</span><span class="n">bump_std_int_width</span> <span class="o">+</span> <span class="n">bump_std_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ctr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_dims</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">inp_int_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">gain</span> <span class="o">=</span> <span class="n">input_bump_gains</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span>
                        <span class="n">ctr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">input_bump_ctrs</span><span class="p">[:,</span> <span class="n">m_i</span><span class="p">])</span>
                        <span class="n">dim_stds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">input_bump_stds</span><span class="p">[:,</span> <span class="n">m_i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gain</span> <span class="o">=</span> <span class="n">int_bump_gains</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span>
                        <span class="n">ctr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">int_bump_ctrs</span><span class="p">[:,</span> <span class="n">m_i</span><span class="p">])</span>
                        <span class="n">dim_stds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">int_bump_stds</span><span class="p">[:,</span> <span class="n">m_i</span><span class="p">])</span>

                <span class="n">mn_f</span> <span class="o">=</span> <span class="n">GaussianBumpFcn</span><span class="p">(</span><span class="n">ctr</span><span class="o">=</span><span class="n">ctr</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">dim_stds</span><span class="p">,</span> <span class="n">peak_vl</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>

                <span class="c1"># Create the standard deviation function</span>
                <span class="n">std_f</span> <span class="o">=</span> <span class="n">ConstantFcn</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="n">prior_std</span><span class="p">]))</span>

                <span class="n">u_modes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondGaussianDistribution</span><span class="p">(</span><span class="n">mn_f</span><span class="o">=</span><span class="n">mn_f</span><span class="p">,</span> <span class="n">std_f</span><span class="o">=</span><span class="n">std_f</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">inp_int_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">input_u_prior</span> <span class="o">=</span> <span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">u_modes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">internal_u_prior</span> <span class="o">=</span> <span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">u_modes</span><span class="p">)</span>

        <span class="c1"># Set the prior distribution for the internal p modes equal to that for the input u modes.  This ensures</span>
        <span class="c1"># that the p modes for internal dynamics will be roughly aligned to the u modes for the input.</span>
        <span class="n">internal_p_prior</span> <span class="o">=</span> <span class="n">input_u_prior</span>

        <span class="c1"># Generate each subject model</span>
        <span class="n">subject_mdls</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_subjects</span>
        <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">):</span>

            <span class="n">n_neurons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n_neuron_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_neuron_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">neuron_pos</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">([</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">])</span>

            <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">IdentityS</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">ConcatenateMap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
            <span class="n">mdl</span> <span class="o">=</span> <span class="n">LatentRegModel</span><span class="p">(</span><span class="n">d_in</span><span class="o">=</span><span class="p">[</span><span class="n">n_modes</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">],</span> <span class="n">d_out</span><span class="o">=</span><span class="p">[</span><span class="n">n_neurons</span><span class="p">],</span> <span class="n">d_proj</span><span class="o">=</span><span class="p">[</span><span class="n">n_modes</span><span class="p">,</span> <span class="n">n_modes</span><span class="p">],</span>
                                 <span class="n">d_trans</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n_modes</span><span class="p">],</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">noise_range</span><span class="o">=</span><span class="n">noise_range</span><span class="p">)</span>

            <span class="n">input_u_modes</span> <span class="o">=</span> <span class="n">input_u_prior</span><span class="o">.</span><span class="n">form_standard_sample</span><span class="p">(</span><span class="n">input_u_prior</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">neuron_pos</span><span class="p">))</span>
            <span class="n">internal_p_modes</span> <span class="o">=</span> <span class="n">internal_p_prior</span><span class="o">.</span><span class="n">form_standard_sample</span><span class="p">(</span><span class="n">internal_p_prior</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">neuron_pos</span><span class="p">))</span>
            <span class="n">internal_u_modes</span> <span class="o">=</span> <span class="n">internal_u_prior</span><span class="o">.</span><span class="n">form_standard_sample</span><span class="p">(</span><span class="n">internal_u_prior</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">neuron_pos</span><span class="p">))</span>

            <span class="n">mdl</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_modes</span><span class="p">)</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">internal_p_modes</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">input_u_modes</span><span class="p">,</span> <span class="n">internal_u_modes</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">neuron_pos</span> <span class="o">=</span> <span class="n">neuron_pos</span>

            <span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdl</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span> <span class="o">=</span> <span class="n">n_modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span> <span class="o">=</span> <span class="n">n_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_u_prior</span> <span class="o">=</span> <span class="n">input_u_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_p_prior</span> <span class="o">=</span> <span class="n">internal_p_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_u_prior</span> <span class="o">=</span> <span class="n">internal_u_prior</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span> <span class="o">=</span> <span class="n">subject_mdls</span>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_training_subject_mdl"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_training_subject_mdl">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_subject_mdl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">assign_p_u</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LatentRegModel</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates a new subject model with random parameters which can be fit to</span>
<span class="sd">            data generated from the scenario.</span>

<span class="sd">            Args:</span>
<span class="sd">                s_i: The subject to generate a model for</span>

<span class="sd">                assign_p_u: True if p and u tensors should be created for the model.  Setting this to false</span>
<span class="sd">                saves memory if the model will be fit with priors over the modes (in which case the p and u</span>
<span class="sd">                modes in the subject model object are ignored.)</span>

<span class="sd">            Returns:</span>
<span class="sd">                mdl: The generated subject model</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">true_mdl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span>
        <span class="n">n_neurons</span> <span class="o">=</span> <span class="n">true_mdl</span><span class="o">.</span><span class="n">neuron_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">IdentityS</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">ConcatenateMap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
        <span class="n">mdl</span> <span class="o">=</span> <span class="n">LatentRegModel</span><span class="p">(</span><span class="n">d_in</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">],</span> <span class="n">d_out</span><span class="o">=</span><span class="p">[</span><span class="n">n_neurons</span><span class="p">],</span>
                                        <span class="n">d_proj</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">],</span>
                                        <span class="n">d_trans</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">],</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                                        <span class="n">assign_p_u</span><span class="o">=</span><span class="n">assign_p_u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">assign_p_u</span><span class="p">:</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">)</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">p_trainable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">mdl</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_training_collection"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_training_collection">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesDataset</span><span class="p">,</span>
                                     <span class="n">mn_init_mn</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mn_init_std</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span>
                                     <span class="n">std_init_vl</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span> <span class="n">post_dists</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubjectVICollection</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates a SubjectVICollection for fitting data to a given subject in the scenario.</span>

<span class="sd">        Args:</span>
<span class="sd">            s_i: The index of the subject to fit to.</span>

<span class="sd">            data: The training data for the subject, as a TimeSeriesDataset in the same convention as returned by</span>
<span class="sd">            generate_data()</span>

<span class="sd">            mn_init_mn, mn_init_std, std_init_vl: Values for initializing distributions on modes.  See</span>
<span class="sd">            generate_training_subject_posteriors for more information.</span>

<span class="sd">            post_dists: If provided, these are the posterior distributions to use for this subject.  If not,</span>
<span class="sd">            posterior distributions will be generated by self.generate_training_subject_posteriors. If provided,</span>
<span class="sd">            post_dists[0] are the distributions for the p modes and post_dists[1] are the distributions for</span>

<span class="sd">        Returns:</span>
<span class="sd">            collection: The generated collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">post_dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_training_subject_posteriors</span><span class="p">(</span><span class="n">s_i</span><span class="o">=</span><span class="n">s_i</span><span class="p">,</span> <span class="n">mn_init_mn</span><span class="o">=</span><span class="n">mn_init_mn</span><span class="p">,</span>
                                                                   <span class="n">mn_init_std</span><span class="o">=</span><span class="n">mn_init_std</span><span class="p">,</span> <span class="n">std_init_vl</span><span class="o">=</span><span class="n">std_init_vl</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SubjectVICollection</span><span class="p">(</span><span class="n">s_mdl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_training_subject_mdl</span><span class="p">(</span><span class="n">s_i</span><span class="p">,</span> <span class="n">assign_p_u</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                   <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                   <span class="n">p_dists</span><span class="o">=</span><span class="n">post_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">u_dists</span><span class="o">=</span><span class="n">post_dists</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">input_grps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                   <span class="n">output_grps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">neuron_pos</span><span class="p">],</span>
                                   <span class="n">input_props</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                   <span class="n">output_props</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">min_var</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">00001</span><span class="p">])</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_shared_posteriors"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_shared_posteriors">[docs]</a>    <span class="k">def</span> <span class="nf">generate_shared_posteriors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_divisions_per_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">n_div_per_hc_side_per_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                                   <span class="n">init_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">001</span><span class="p">,</span> <span class="n">min_std</span> <span class="o">=</span> <span class="o">.</span><span class="mi">00001</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates a shared posterior for fitting across models.</span>

<span class="sd">        Posteriors are based on hypercube mean and standard deviation functions.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_divisions_per_dim: The number of divisons per dimension to use when generating hypercube functions.  There</span>
<span class="sd">            will be the same number of divisions for each dimension.</span>

<span class="sd">            n_div_per_hc_side_per_dim: The number of divisions per hypercube per dimension to use when generating</span>
<span class="sd">            hypercube functions.  This will be the same for all dimensions.</span>

<span class="sd">            init_std: The initial standard deviation for the conditional distribution for each mode.  The standard</span>
<span class="sd">            deviation will take on this value everywhere.</span>

<span class="sd">            min_std: The minimum standard deviation the posterior distributions can take on.</span>

<span class="sd">        Note: Because input p modes are assumed fixed and know, a posterior is not generated for these nodes.</span>
<span class="sd">        Instead a fixed tensor will be generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dists: dists[0] are the posterior distributions for the p modes.  dists[0][0] is a tensor for the input</span>
<span class="sd">            p modes and dists[0][1] is a conditional distribution for the internal p modes. dists[1][0] is a</span>
<span class="sd">            conditional distribution for the u modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Our posteriors are the same form as our priors, allowing us to re-use code</span>
        <span class="n">posts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_fitting_priors</span><span class="p">(</span><span class="n">n_divisions_per_dim</span><span class="o">=</span><span class="n">n_divisions_per_dim</span><span class="p">,</span>
                                             <span class="n">n_div_per_hc_side_per_dim</span><span class="o">=</span><span class="n">n_div_per_hc_side_per_dim</span><span class="p">,</span>
                                             <span class="n">init_std</span><span class="o">=</span><span class="n">init_std</span><span class="p">,</span> <span class="n">min_std</span><span class="o">=</span><span class="n">min_std</span><span class="p">)</span>

        <span class="n">posts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">posts</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_training_subject_posteriors"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_training_subject_posteriors">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_subject_posteriors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mn_init_mn</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mn_init_std</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span>
                                             <span class="n">std_init_vl</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates the posterior distributions for a given subject for variational inference.</span>

<span class="sd">        Because the input p modes are assumed fixed and known, a tensor is returned in place of a distribution</span>
<span class="sd">        for these modes.</span>

<span class="sd">        Args:</span>
<span class="sd">            s_i: The subject to generate posteriors for</span>

<span class="sd">            mn_init_mn, mn_init_std: The mean and standard deviation of the normal distribution the initial mean values</span>
<span class="sd">            for each mode distribution are sampled from.</span>

<span class="sd">            std_init_vl: The initial standard deviation for each mode distribution.  The standard deviation of each</span>
<span class="sd">            conditional distribution is initially the same for all neuron positions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dists: dists[0] are the posterior distributions for the p modes.  dists[0][0] is a tensor for the input</span>
<span class="sd">            p modes and dists[0][1] is a conditional distribution for the internal p modes. dists[1][0] is a</span>
<span class="sd">            conditional distribution for the u modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">neuron_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># The input p tensor is fixed</span>
        <span class="n">input_p</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">)</span>

        <span class="c1"># Generate the distribution over internal p modes</span>
        <span class="n">internal_p_mode_dists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span>
        <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">):</span>
            <span class="n">mn_f</span> <span class="o">=</span> <span class="n">IndSmpConstantRealFcn</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">init_mn</span><span class="o">=</span><span class="n">mn_init_mn</span><span class="p">,</span> <span class="n">init_std</span><span class="o">=</span><span class="n">mn_init_std</span><span class="p">)</span>
            <span class="n">std_f</span> <span class="o">=</span> <span class="n">IndSmpConstantBoundedFcn</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=.</span><span class="mi">00001</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                             <span class="n">init_value</span><span class="o">=</span><span class="n">std_init_vl</span><span class="p">)</span>
            <span class="n">internal_p_mode_dists</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondGaussianDistribution</span><span class="p">(</span><span class="n">mn_f</span><span class="o">=</span><span class="n">mn_f</span><span class="p">,</span> <span class="n">std_f</span><span class="o">=</span><span class="n">std_f</span><span class="p">)</span>

        <span class="n">internal_p_dist</span> <span class="o">=</span> <span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">internal_p_mode_dists</span><span class="p">)</span>

        <span class="n">u_mode_dists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">):</span>
            <span class="n">mn_f</span> <span class="o">=</span> <span class="n">IndSmpConstantRealFcn</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">init_mn</span><span class="o">=</span><span class="n">mn_init_mn</span><span class="p">,</span> <span class="n">init_std</span><span class="o">=</span><span class="n">mn_init_std</span><span class="p">)</span>
            <span class="n">std_f</span> <span class="o">=</span> <span class="n">IndSmpConstantBoundedFcn</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=.</span><span class="mi">00001</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                             <span class="n">init_value</span><span class="o">=</span><span class="n">std_init_vl</span><span class="p">)</span>
            <span class="n">u_mode_dists</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondGaussianDistribution</span><span class="p">(</span><span class="n">mn_f</span><span class="o">=</span><span class="n">mn_f</span><span class="p">,</span> <span class="n">std_f</span><span class="o">=</span><span class="n">std_f</span><span class="p">)</span>

        <span class="n">u_dist</span> <span class="o">=</span> <span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">u_mode_dists</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[[</span><span class="n">input_p</span><span class="p">,</span> <span class="n">internal_p_dist</span><span class="p">],</span> <span class="p">[</span><span class="n">u_dist</span><span class="p">]]</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_fitting_priors"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_fitting_priors">[docs]</a>    <span class="k">def</span> <span class="nf">generate_fitting_priors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_divisions_per_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">n_div_per_hc_side_per_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                               <span class="n">init_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">001</span><span class="p">,</span> <span class="n">min_std</span> <span class="o">=</span> <span class="o">.</span><span class="mi">00001</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates priors for fitting multiple models with variational inference.</span>

<span class="sd">        Note: Because the input p modes are assumed fixed and known, a prior is not generate for these</span>
<span class="sd">        modes and the value None is returned in its place (see below).</span>

<span class="sd">        Args:</span>
<span class="sd">            n_divisions_per_dim: The number of divisons per dimension to use when generating hypercube functions.  There</span>
<span class="sd">            will be the same number of divisions for each dimension.</span>

<span class="sd">            n_div_per_hc_side_per_dim: The number of divisions per hypercube per dimension to use when generating</span>
<span class="sd">            hypercube functions.  This will be the same for all dimensions.</span>

<span class="sd">            init_std: The initial standard deviation for the conditional distribution for each mode.  The standard</span>
<span class="sd">            deviation will take on this value everywhere.</span>

<span class="sd">            min_std: The minimum standard deviation the prior distributions can take on.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dists: dists[0] is the distributions for the p modes.  dists[0][0] is None to indicate there is no</span>
<span class="sd">            prior distribution over the input p modes and dists[0][1] is the distribution over the internal p modes.</span>
<span class="sd">            dists[1][0] is the distribution over the u modes.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If min_std or init_std is less than 0</span>
<span class="sd">            ValueError: If init_std is less than min_std</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">init_std</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;init_std must be greater than 0&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_std</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;min_std must be greater than 0&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">init_std</span> <span class="o">&lt;</span> <span class="n">min_std</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;min_std must be less than init_std&#39;</span><span class="p">))</span>

        <span class="n">n_div_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_divisions_per_dim</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span>
        <span class="n">dim_ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">dim_ranges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">n_div_per_hc</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_div_per_hc_side_per_dim</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span>

        <span class="c1"># Generate internal p mode distributions</span>
        <span class="n">internal_p_mode_dists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span>
        <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">):</span>
            <span class="n">mn_f</span> <span class="o">=</span> <span class="n">SumOfTiledHyperCubeBasisFcns</span><span class="p">(</span><span class="n">n_divisions_per_dim</span><span class="o">=</span><span class="n">n_div_per_dim</span><span class="p">,</span> <span class="n">dim_ranges</span><span class="o">=</span><span class="n">dim_ranges</span><span class="p">,</span>
                                                <span class="n">n_div_per_hc_side_per_dim</span><span class="o">=</span><span class="n">n_div_per_hc</span><span class="p">)</span>
            <span class="n">std_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">SumOfTiledHyperCubeBasisFcns</span><span class="p">(</span><span class="n">n_divisions_per_dim</span><span class="o">=</span><span class="n">n_div_per_dim</span><span class="p">,</span> <span class="n">dim_ranges</span><span class="o">=</span><span class="n">dim_ranges</span><span class="p">,</span>
                                                <span class="n">n_div_per_hc_side_per_dim</span><span class="o">=</span><span class="n">n_div_per_hc</span><span class="p">),</span> <span class="n">FixedOffsetExp</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="n">min_std</span><span class="p">))</span>
            <span class="c1"># Set the initial standard deviation</span>
            <span class="n">std_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">b_m</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">init_std</span> <span class="o">-</span> <span class="n">min_std</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n_div_per_hc_side_per_dim</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span><span class="p">)</span>

            <span class="n">internal_p_mode_dists</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondGaussianDistribution</span><span class="p">(</span><span class="n">mn_f</span><span class="o">=</span><span class="n">mn_f</span><span class="p">,</span> <span class="n">std_f</span><span class="o">=</span><span class="n">std_f</span><span class="p">)</span>

        <span class="n">internal_p_dist</span> <span class="o">=</span> <span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">internal_p_mode_dists</span><span class="p">)</span>

        <span class="c1"># Generate the u mode distributions</span>
        <span class="n">u_mode_dists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">):</span>
            <span class="n">mn_f</span> <span class="o">=</span> <span class="n">SumOfTiledHyperCubeBasisFcns</span><span class="p">(</span><span class="n">n_divisions_per_dim</span><span class="o">=</span><span class="n">n_div_per_dim</span><span class="p">,</span> <span class="n">dim_ranges</span><span class="o">=</span><span class="n">dim_ranges</span><span class="p">,</span>
                                                <span class="n">n_div_per_hc_side_per_dim</span><span class="o">=</span><span class="n">n_div_per_hc</span><span class="p">)</span>
            <span class="n">std_f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">SumOfTiledHyperCubeBasisFcns</span><span class="p">(</span><span class="n">n_divisions_per_dim</span><span class="o">=</span><span class="n">n_div_per_dim</span><span class="p">,</span> <span class="n">dim_ranges</span><span class="o">=</span><span class="n">dim_ranges</span><span class="p">,</span>
                                                <span class="n">n_div_per_hc_side_per_dim</span><span class="o">=</span><span class="n">n_div_per_hc</span><span class="p">),</span> <span class="n">FixedOffsetExp</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="n">min_std</span><span class="p">))</span>
            <span class="c1"># Set the initial standard deviation</span>
            <span class="n">std_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">b_m</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">init_std</span> <span class="o">-</span> <span class="n">min_std</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n_div_per_hc_side_per_dim</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n_dims</span><span class="p">)</span>

            <span class="n">u_mode_dists</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondGaussianDistribution</span><span class="p">(</span><span class="n">mn_f</span><span class="o">=</span><span class="n">mn_f</span><span class="p">,</span> <span class="n">std_f</span><span class="o">=</span><span class="n">std_f</span><span class="p">)</span>

        <span class="n">u_dist</span> <span class="o">=</span> <span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">u_mode_dists</span><span class="p">)</span>

        <span class="n">p_dists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">internal_p_dist</span><span class="p">]</span>
        <span class="n">u_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_dist</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">p_dists</span><span class="p">,</span> <span class="n">u_dists</span><span class="p">]</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_data"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_data">[docs]</a>    <span class="k">def</span> <span class="nf">generate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stimuli</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates data from subject models given time series of input to each model.</span>

<span class="sd">        Args:</span>
<span class="sd">            stimuli: stimuli[i] contains the input tensor for subject model i.</span>

<span class="sd">        Returns:</span>
<span class="sd">            data: data[i] contains data for subject i as a TimeSeriesDataset. The first tensor in</span>
<span class="sd">            each dataset will be input stimulus and the second will be neural data.  Data are</span>
<span class="sd">            &quot;time locked&quot; that is the t^th point in the returned stimulus and the t^th point in</span>
<span class="sd">            the returned neural data is the data that generated the (t+1)^th data point in the neural</span>
<span class="sd">            data.  This requires discarding the first point in the provided stimulus, so there will</span>
<span class="sd">            only by T-1 data points in the returned dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_subjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stimuli</span><span class="p">)</span>
        <span class="n">neural_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_subjects</span>
        <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">):</span>
            <span class="n">n_smps</span> <span class="o">=</span> <span class="n">stimuli</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_neurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">neural_inputs</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_smps</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">])</span>
            <span class="n">neural_inputs</span><span class="p">[</span><span class="n">s_i</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neural_inputs</span><span class="p">[</span><span class="n">s_i</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">sim_inputs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stimuli</span><span class="p">,</span> <span class="n">neural_inputs</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_m</span><span class="o">.</span><span class="n">recursive_generate</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">s_i</span><span class="p">,</span> <span class="n">r_map</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
                  <span class="k">for</span> <span class="n">s_m</span><span class="p">,</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">,</span> <span class="n">sim_inputs</span><span class="p">)]</span>

        <span class="c1"># Now produce a time locked version of stimulus and output</span>
        <span class="n">tl_stimuli</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="n">stimuli</span><span class="p">]</span>
        <span class="n">tl_output</span> <span class="o">=</span> <span class="p">[</span><span class="n">o_i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="k">for</span> <span class="n">o_i</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">TimeSeriesDataset</span><span class="p">([</span><span class="n">tl_stimuli</span><span class="p">[</span><span class="n">s_i</span><span class="p">],</span> <span class="n">tl_output</span><span class="p">[</span><span class="n">s_i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">)]</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_random_input_data"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_random_input_data">[docs]</a>    <span class="k">def</span> <span class="nf">generate_random_input_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_smps_per_subject</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">input_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; Generates data from each subject model as they receive random input.</span>

<span class="sd">        Data for each input is generated iid from a N(0, input_std^2) distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_smps_per_subject: n_smps_per_subject[i] is the number of random input samples to generate from subject</span>
<span class="sd">            i.</span>

<span class="sd">            input_std: The standard deviation of the input signals.</span>

<span class="sd">        Returns:</span>
<span class="sd">           data: data[i] is the data for subject i, the formatted described in generate_data()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_std</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">([</span><span class="n">n_smps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">])</span> <span class="k">for</span> <span class="n">n_smps</span> <span class="ow">in</span> <span class="n">n_smps_per_subject</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_data</span><span class="p">(</span><span class="n">stimuli</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span></div>

<div class="viewcode-block" id="BumpInputWithRecursiveDynamicsScenario.generate_one_input_mode_random_input_data"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.BumpInputWithRecursiveDynamicsScenario.generate_one_input_mode_random_input_data">[docs]</a>    <span class="k">def</span> <span class="nf">generate_one_input_mode_random_input_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_smps_per_subject</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                               <span class="n">input_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; Generates data where only one input mode is excited with random input per subject.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_smps_per_subject: n_smps_per_subject[i] is the number of random input samples to generate from subject</span>
<span class="sd">            i.</span>

<span class="sd">            input_std: The standard deviation of the input signals.</span>

<span class="sd">        Returns:</span>
<span class="sd">           data: data[i] is the data for subject i, the formatted described in generate_data()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_subjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_smps_per_subject</span><span class="p">)</span>

        <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_subjects</span>
        <span class="k">for</span> <span class="n">s_i</span><span class="p">,</span> <span class="n">n_smps</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">n_smps_per_subject</span><span class="p">):</span>
            <span class="n">mode_i</span> <span class="o">=</span> <span class="n">s_i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span>
            <span class="n">s_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_smps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_modes</span><span class="p">])</span>
            <span class="n">s_input</span><span class="p">[:,</span> <span class="n">mode_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_std</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">([</span><span class="n">n_smps</span><span class="p">])</span>
            <span class="nb">input</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_input</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_data</span><span class="p">(</span><span class="n">stimuli</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SplitPropertiesScenario"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario">[docs]</a><span class="k">class</span> <span class="nc">SplitPropertiesScenario</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; An object for simulating a scenario where neuron couplings depend on two or more sets of properties.</span>

<span class="sd">    For simplicity, we simulate neuron properties as distributed uniformly in a unit hypercube in each property space.</span>

<span class="sd">    Other than having neuron properties depend on two or more sets of properties, we try to keep everything</span>
<span class="sd">    else in this scenario as simple as possible.  In particular, we simulate a model of neurons driving one</span>
<span class="sd">    behavioral variable.  This means we have one p-mode per subject and fixed (scalar) u mode with value 1.  The</span>
<span class="sd">    coefficients of the p-mode depend on two sets of properties.  We assume identiy m-module and s-modules.</span>

<span class="sd">    To generating a p-mode coupling for a given subject&#39;s neuron , we pull from</span>
<span class="sd">    a N(m(p_i^0, p_i^1, ..., p_i^J), \sigma^2) distribution where m() is of the form:</span>

<span class="sd">        m(p_i^0, p_i^1, ..., p_i^J) = k*\prod_j^J b_j(p_i^j),</span>

<span class="sd">    where b_j is an axis-aligned Gaussian bump function parameterized by a center and standard deviation along</span>
<span class="sd">    each axis.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SplitPropertiesScenario._bmp_fcn"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario._bmp_fcn">[docs]</a>    <span class="k">def</span> <span class="nf">_bmp_fcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_j</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">x_j</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bump_centers</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bump_stds</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="SplitPropertiesScenario._m"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario._m">[docs]</a>    <span class="k">def</span> <span class="nf">_m</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bump_k</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_bmp_fcn</span><span class="p">(</span><span class="n">x_j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span>
                                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">bump_k</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">bump_centers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">bump_stds</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">coupling_std</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">psi_noise_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new SplitPropertiesScenario object.</span>

<span class="sd">        Args:</span>

<span class="sd">            n_neurons: The length of n_neurons defines the number of subjects in the simulation. n_neurons[i]</span>
<span class="sd">            is the number of neurons to simulate for subject i.</span>

<span class="sd">            bump_k: The extreme value any coupling can take on.</span>

<span class="sd">            bump_centers: bump_centers[j] is where b_j is centered.  The length of bump_centers defines how many</span>
<span class="sd">            sets of properties there, and the length of bump_centers[j] implicitly defines the dimensionality of the</span>
<span class="sd">            j^th property space.</span>

<span class="sd">            bump_stds: Bump functions are axis aligned.  bump_stds[j][i] is the standard deviation of b_j along</span>
<span class="sd">            dimension i.</span>

<span class="sd">            coupling_std: The standard deviation of the distrubtion on couplings</span>

<span class="sd">            psi_noise_range: The range to pull psi values from when generating the latent regression model for</span>
<span class="sd">            each subject</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_subjects</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span>
        <span class="n">n_prop_spaces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bump_centers</span><span class="p">)</span>
        <span class="n">prop_dims</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">b_c</span><span class="p">)</span> <span class="k">for</span> <span class="n">b_c</span> <span class="ow">in</span> <span class="n">bump_centers</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_subjects</span> <span class="o">=</span> <span class="n">n_subjects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span> <span class="o">=</span> <span class="n">n_neurons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bump_k</span> <span class="o">=</span> <span class="n">bump_k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bump_centers</span> <span class="o">=</span> <span class="n">bump_centers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bump_stds</span> <span class="o">=</span> <span class="n">bump_stds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_std</span> <span class="o">=</span> <span class="n">coupling_std</span>

        <span class="c1"># Generate subject models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_subjects</span>
        <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_subjects</span><span class="p">):</span>
                <span class="n">neuron_props_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">],</span> <span class="n">prop_dims</span><span class="p">[</span><span class="n">p_j</span><span class="p">])</span> <span class="k">for</span> <span class="n">p_j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_prop_spaces</span><span class="p">)]</span>

                <span class="n">mdl</span> <span class="o">=</span> <span class="n">LatentRegModel</span><span class="p">(</span><span class="n">d_in</span><span class="o">=</span><span class="p">[</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">]],</span> <span class="n">d_out</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_proj</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_trans</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">m</span><span class="o">=</span><span class="n">IdentityMap</span><span class="p">(),</span> <span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="n">IdentityS</span><span class="p">()],</span> <span class="n">noise_range</span><span class="o">=</span><span class="n">psi_noise_range</span><span class="p">)</span>

                <span class="c1"># Concatenate properties, noting indices that form each set of properties</span>
                <span class="n">prop_set_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">props_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;long&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">props_i</span> <span class="ow">in</span> <span class="n">neuron_props_i</span><span class="p">]</span>
                <span class="n">prev_n_props</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_prop_spaces</span><span class="p">):</span>
                    <span class="n">prop_set_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop_set_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev_n_props</span>
                    <span class="n">prev_n_props</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prop_set_inds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="n">mdl</span><span class="o">.</span><span class="n">neuron_prop_set_inds</span> <span class="o">=</span> <span class="n">prop_set_inds</span>
                <span class="n">mdl</span><span class="o">.</span><span class="n">neuron_props</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">neuron_props_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

                <span class="n">mdl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">p_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m</span><span class="p">(</span><span class="n">neuron_props_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">coupling_std</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">])</span>
                <span class="n">p_mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p_mode</span><span class="p">,</span> <span class="p">[</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">mdl</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">p_mode</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdl</span>

<div class="viewcode-block" id="SplitPropertiesScenario.generate_data"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario.generate_data">[docs]</a>    <span class="k">def</span> <span class="nf">generate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_tm_pts</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TimeSeriesDataset</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; Generates simulated data for the scenario.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_tm_pts: n_tm_pts[i] is the number of time points to generate for subject i</span>

<span class="sd">        Returns:</span>
<span class="sd">            data: data[i] is the data for subject i as a TimeSeriesDataset object.  The first entry in the .data</span>
<span class="sd">            attribute of the object will be neural data and the second will be behavioral data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_subjects</span>

        <span class="k">for</span> <span class="n">s_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_subjects</span><span class="p">):</span>
            <span class="n">neural_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_tm_pts</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">])</span>
            <span class="n">beh_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">generate</span><span class="p">([</span><span class="n">neural_data</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeSeriesDataset</span><span class="p">([</span><span class="n">neural_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">beh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]])</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="SplitPropertiesScenario.generate_training_subject_mdl"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario.generate_training_subject_mdl">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_subject_mdl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">assign_p_u</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="n">psi_noise_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">LatentRegModel</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates a new subject model for training.</span>

<span class="sd">        Args:</span>
<span class="sd">            s_i: The subject to generate a model for</span>

<span class="sd">            assign_p_u: True if p and u tensors should be created for the model.  Setting this to false</span>
<span class="sd">            saves memory if the model will be fit with priors over the modes (in which case the p and u</span>
<span class="sd">            modes in the subject model object are ignored.)</span>

<span class="sd">            psi_noise_range: The range of values to initialize psi with</span>

<span class="sd">            Returns:</span>
<span class="sd">                mdl: The generated subject model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mdl</span> <span class="o">=</span> <span class="n">LatentRegModel</span><span class="p">(</span><span class="n">d_in</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">]],</span> <span class="n">d_out</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_proj</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_trans</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">m</span><span class="o">=</span><span class="n">IdentityMap</span><span class="p">(),</span> <span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="n">IdentityS</span><span class="p">()],</span> <span class="n">noise_range</span><span class="o">=</span><span class="n">psi_noise_range</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">assign_p_u</span><span class="p">:</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">mdl</span><span class="o">.</span><span class="n">u_trainable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">mdl</span></div>

<div class="viewcode-block" id="SplitPropertiesScenario.generate_training_subject_posteriors"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario.generate_training_subject_posteriors">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_subject_posteriors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mn_init_mn</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mn_init_std</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span>
                                             <span class="n">std_init_vl</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates the posterior distributions for a given subject for variational inference.</span>

<span class="sd">        Because the u mode is assumed fixed and known, a tensor is returned in place of a distribution</span>
<span class="sd">        for this mode.</span>

<span class="sd">        Args:</span>
<span class="sd">            s_i: The subject to generate posteriors for</span>

<span class="sd">            mn_init_mn, mn_init_std: The mean and standard deviation of the normal distribution the initial values</span>
<span class="sd">            for the mean of the distribution on the p mode are sampled from.</span>

<span class="sd">            std_init_vl: The initial standard deviation for each entry in the p-mode.  The standard deviation is</span>
<span class="sd">            initially the same for all neurons.</span>

<span class="sd">        Returns:</span>
<span class="sd">            p_dists: p_dists[0] is the distribtion on the p modes</span>

<span class="sd">            u_dists: u_dists[0] is a 1*1 tensor with value 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate the distribution over the p mode</span>
        <span class="n">mn_f</span> <span class="o">=</span> <span class="n">IndSmpConstantRealFcn</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">],</span> <span class="n">init_mn</span><span class="o">=</span><span class="n">mn_init_mn</span><span class="p">,</span> <span class="n">init_std</span><span class="o">=</span><span class="n">mn_init_std</span><span class="p">)</span>
        <span class="n">std_f</span> <span class="o">=</span> <span class="n">IndSmpConstantBoundedFcn</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neurons</span><span class="p">[</span><span class="n">s_i</span><span class="p">],</span> <span class="n">lower_bound</span><span class="o">=.</span><span class="mi">00001</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                         <span class="n">init_value</span><span class="o">=</span><span class="n">std_init_vl</span><span class="p">)</span>

        <span class="n">p_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">CondMatrixProductDistribution</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="p">[</span><span class="n">CondGaussianDistribution</span><span class="p">(</span><span class="n">mn_f</span><span class="o">=</span><span class="n">mn_f</span><span class="p">,</span> <span class="n">std_f</span><span class="o">=</span><span class="n">std_f</span><span class="p">)])]</span>
        <span class="n">u_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">p_dists</span><span class="p">,</span> <span class="n">u_dists</span><span class="p">]</span></div>

<div class="viewcode-block" id="SplitPropertiesScenario.generate_training_collection"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario.generate_training_collection">[docs]</a>    <span class="k">def</span> <span class="nf">generate_training_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TimeSeriesDataset</span><span class="p">,</span>
                                     <span class="n">mn_init_mn</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mn_init_std</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span>
                                     <span class="n">std_init_vl</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span> <span class="n">post_dists</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SubjectVICollection</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates a SubjectVICollection for fitting data to a given subject in the scenario.</span>

<span class="sd">        Args:</span>
<span class="sd">            s_i: The index of the subject to fit to.</span>

<span class="sd">            data: The training data for the subject, as a TimeSeriesDataset in the same convention as returned by</span>
<span class="sd">            generate_data()</span>

<span class="sd">            mn_init_mn, mn_init_std, std_init_vl: Values for initializing distributions on modes.  See</span>
<span class="sd">            generate_training_subject_posteriors for more information.</span>

<span class="sd">            post_dists: If provided, these are the posterior distributions to use for this subject.  If not,</span>
<span class="sd">            posterior distributions will be generated by self.generate_training_subject_posteriors. If provided,</span>
<span class="sd">            post_dists[0] are the distributions for the p modes and post_dists[1] are the distributions for</span>

<span class="sd">        Returns:</span>
<span class="sd">            collection: The generated collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">post_dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_training_subject_posteriors</span><span class="p">(</span><span class="n">s_i</span><span class="o">=</span><span class="n">s_i</span><span class="p">,</span> <span class="n">mn_init_mn</span><span class="o">=</span><span class="n">mn_init_mn</span><span class="p">,</span>
                                                                   <span class="n">mn_init_std</span><span class="o">=</span><span class="n">mn_init_std</span><span class="p">,</span> <span class="n">std_init_vl</span><span class="o">=</span><span class="n">std_init_vl</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SubjectVICollection</span><span class="p">(</span><span class="n">s_mdl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_training_subject_mdl</span><span class="p">(</span><span class="n">s_i</span><span class="p">,</span> <span class="n">assign_p_u</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                   <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                                   <span class="n">p_dists</span><span class="o">=</span><span class="n">post_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">u_dists</span><span class="o">=</span><span class="n">post_dists</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">input_grps</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">output_grps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subject_mdls</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">neuron_props</span><span class="p">],</span>
                                   <span class="n">input_props</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">output_props</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span>
                                   <span class="n">min_var</span><span class="o">=</span><span class="p">[</span><span class="o">.</span><span class="mi">00001</span><span class="p">])</span></div>

<div class="viewcode-block" id="SplitPropertiesScenario.generate_fitting_priors"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.SplitPropertiesScenario.generate_fitting_priors">[docs]</a>    <span class="k">def</span> <span class="nf">generate_fitting_priors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_inds</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">],</span>
                                <span class="n">n_divisions_per_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">n_div_per_hc_side_per_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                                <span class="n">init_mn</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">,</span> <span class="n">init_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">.</span><span class="mi">001</span><span class="p">,</span> <span class="n">min_std</span> <span class="o">=</span> <span class="o">.</span><span class="mi">00001</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Generates prior for fitting multiple models with variational inference.</span>

<span class="sd">        The only mode to generate a prior for in this scenario is the single p mode.  For neuron i with properties</span>
<span class="sd">        p_i^0, ... p_i^J, the prior conditioned on properties will be N(m(p_i^0, ... p_i^J), s^2(p_i^0, ... p_i^J)),</span>
<span class="sd">        where m() is of the form:</span>

<span class="sd">            m(p_i^0, ... p_i^J) = l*exp(\sum_{j=1}^J h_j^m(p_i^j) + d) + o,</span>

<span class="sd">        where each h_j^m is a hypercube function, d is a shift, o is an offset and l is a scale.</span>

<span class="sd">        The function s() is of the form:</span>

<span class="sd">            s(p_i^0, ... p_i^J) = exp(\sum_{j=1}^J h_j^s(p_i^j)) + o_fixed,</span>

<span class="sd">        where each h_j^s is again a hypercube function and o_fixed is a non-learnable parameter with a small</span>
<span class="sd">        positive value to ensure the output of s() is strictly positive.</span>

<span class="sd">        The priors will assume all of the properties have been concatenated together, and therefore, the</span>
<span class="sd">        user has to specify which dimensions of the concatenated properties belong to each set (see set_inds below).</span>

<span class="sd">        Note: Because u mode is assumed fixed and known, a prior is not generated for this mode</span>
<span class="sd">        and the value None is returned in its place (see below).</span>

<span class="sd">        Args:</span>

<span class="sd">            set_inds: Priors are created assuming properties will be provided in a tensor of</span>
<span class="sd">            shape n_neurons*n_total_prop_dims.  set_inds[i] gives the columns of the property tensor corresponding</span>
<span class="sd">            to the properties for property space i.</span>

<span class="sd">            n_divisions_per_dim: The number of divisons per dimension to use when generating hypercube functions.  There</span>
<span class="sd">            will be the same number of divisions for each dimension.</span>

<span class="sd">            n_div_per_hc_side_per_dim: The number of divisions per hypercube per dimension to use when generating</span>
<span class="sd">            hypercube functions.  This will be the same for all dimensions.</span>

<span class="sd">            init_mn: The initial mean for the conditional distribution for the p mode.  The mean will take on</span>
<span class="sd">            this value everywhere.</span>

<span class="sd">            init_std: The initial standard deviation for the conditional distribution for the p mode.  The standard</span>
<span class="sd">            deviation will take on this value everywhere.</span>

<span class="sd">            min_std: The minimum standard deviation the prior distributions can take on.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If min_std or init_std is less than 0</span>
<span class="sd">            ValueError: If init_std is less than min_std</span>

<span class="sd">        Returns:</span>

<span class="sd">            p_dists: p_dists[0] is the distribution for the p mode</span>

<span class="sd">            u_dists: u_dists[0] is None to signify there is no prior distribution over the u modes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">init_std</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;init_std must be greater than 0&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">min_std</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;min_std must be greater than 0&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">init_std</span> <span class="o">&lt;</span> <span class="n">min_std</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;min_std must be less than init_std&#39;</span><span class="p">))</span>

        <span class="n">n_prop_spaces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_inds</span><span class="p">)</span>
        <span class="n">prop_space_dims</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">set_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">set_i</span> <span class="ow">in</span> <span class="n">set_inds</span><span class="p">]</span>
        <span class="n">space_dim_ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">d_i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="n">prop_space_dims</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_prop_spaces</span><span class="p">):</span>
            <span class="n">space_dim_ranges</span><span class="p">[</span><span class="n">p_i</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">hc_params</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;n_divisions_per_dim&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">n_divisions_per_dim</span><span class="p">]</span><span class="o">*</span><span class="n">prop_space_dims</span><span class="p">[</span><span class="n">p_i</span><span class="p">],</span>
                      <span class="s1">&#39;dim_ranges&#39;</span><span class="p">:</span> <span class="n">space_dim_ranges</span><span class="p">[</span><span class="n">p_i</span><span class="p">],</span>
                      <span class="s1">&#39;n_div_per_hc_side_per_dim&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">n_div_per_hc_side_per_dim</span><span class="p">]</span><span class="o">*</span><span class="n">prop_space_dims</span><span class="p">[</span><span class="n">p_i</span><span class="p">]}</span>
                      <span class="k">for</span> <span class="n">p_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_prop_spaces</span><span class="p">)]</span>

        <span class="n">p_dist</span> <span class="o">=</span> <span class="n">GroupCondMatrixHypercubePrior</span><span class="p">(</span><span class="n">n_cols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">group_inds</span><span class="o">=</span><span class="n">set_inds</span><span class="p">,</span>
                                               <span class="n">mn_hc_params</span><span class="o">=</span><span class="n">hc_params</span><span class="p">,</span> <span class="n">std_hc_params</span><span class="o">=</span><span class="n">hc_params</span><span class="p">,</span>
                                               <span class="n">min_std</span><span class="o">=</span><span class="n">min_std</span><span class="p">,</span> <span class="n">mn_init</span><span class="o">=</span><span class="n">init_mn</span><span class="p">,</span> <span class="n">std_init</span><span class="o">=</span><span class="n">init_std</span><span class="p">)</span>

        <span class="n">p_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_dist</span><span class="p">]</span>
        <span class="n">u_dists</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">p_dists</span><span class="p">,</span> <span class="n">u_dists</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="plot_single_2d_conditional_prior"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.plot_single_2d_conditional_prior">[docs]</a><span class="k">def</span> <span class="nf">plot_single_2d_conditional_prior</span><span class="p">(</span><span class="n">priors</span><span class="p">:</span> <span class="n">CondMatrixProductDistribution</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                     <span class="n">dim_sampling</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">]],</span>
                                     <span class="nb">range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_mn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plots a prior distribution of a neuron&#39;s loading given neuron&#39;s location in a 2-d space for a single mode.</span>

<span class="sd">    Args:</span>
<span class="sd">        priors: The conditional prior distribution over modes.</span>

<span class="sd">        mode: The index of the mode for the prior to plot.</span>

<span class="sd">        dim_sampling: Each entry of dim_sampling specifies how to sample a dimension in the</span>
<span class="sd">        domain of the function.  Each entry is of the form [start, stop, int] where start and</span>
<span class="sd">        and stop are the start and stop of the range of values to sample from and int</span>
<span class="sd">        is the interval values are sampled from.</span>

<span class="sd">        range: If provided, colors for values will saturate at +/- range.  If not provided, this</span>
<span class="sd">        is set based on the values to be plotted.</span>

<span class="sd">        plot_mn: If true, the mean will be plotted.  If false, the standard deviation is plotted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Determine coordinates we will sample from along each dimension</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">dim_sampling</span><span class="p">]</span>

    <span class="c1"># Form coordinates of each point we will sample from in a single numpy array</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">n_pts</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">flat_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">n_pts</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">n_coords_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>

    <span class="c1"># Get the mean and standard deviation of the unrotated modes at each point in the grid</span>
    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">priors</span><span class="p">(</span><span class="n">flat_grid</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">d</span><span class="p">(</span><span class="n">flat_grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">dists</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># Rotate modes</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_modes</span> <span class="o">=</span> <span class="n">mode_mn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_modes</span><span class="p">)</span>

    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mode_mn</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mode_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Get the mode we are to plot</span>
    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">mode_mn</span><span class="p">[:,</span> <span class="n">mode</span><span class="p">]</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">mode_std</span><span class="p">[:,</span> <span class="n">mode</span><span class="p">]</span>

    <span class="c1"># Put the mean and standard deviation in images</span>
    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">mode_mn</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_coords_per_dim</span><span class="p">)</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">mode_std</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_coords_per_dim</span><span class="p">)</span>

    <span class="c1"># Determine the axes ratio of the images we will plot</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dim_sampling</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dim_sampling</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Get the mean or std image</span>
    <span class="k">if</span> <span class="n">plot_mn</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">mode_mn</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">mode_std</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># Get the max absolute values for the images</span>
    <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot_mn</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="nb">range</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PiYG&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;cool&#39;</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="nb">range</span>

    <span class="c1"># Plot image</span>
    <span class="n">plot_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>
    <span class="n">plotted_im</span> <span class="o">=</span> <span class="n">plot_axes</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">plotted_im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">plot_axes</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_2d_conditional_prior"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.plot_2d_conditional_prior">[docs]</a><span class="k">def</span> <span class="nf">plot_2d_conditional_prior</span><span class="p">(</span><span class="n">priors</span><span class="p">:</span> <span class="n">CondMatrixProductDistribution</span><span class="p">,</span>
                              <span class="n">dim_sampling</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">]],</span>
                              <span class="n">mn_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">std_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plots a conditional prior distribution of a neuron&#39;s loading given neurons location in a 2-d space.</span>

<span class="sd">    The spatial means and standard deviations of each mode will be plotted in a 2 by M grid layout - each column</span>
<span class="sd">    is a mode with means plotted on top and standard deviations plotted on bottom.</span>

<span class="sd">    Args:</span>
<span class="sd">        priors: The conditional prior distribution over modes.</span>

<span class="sd">        dim_sampling: Each entry of dim_sampling specifies how to sample a dimension in the</span>
<span class="sd">        domain of the fuction.  Each entry is of the form [start, stop, int] where start and</span>
<span class="sd">        and stop are the start and stop of the range of values to sample from and int</span>
<span class="sd">        is the interval values are sampled from.</span>

<span class="sd">        mn_range: If provided, colors for mean values will saturate at +/- mn_range.  If not provided, this</span>
<span class="sd">        is set based on the means to be plotted.</span>

<span class="sd">        std_range: If provided, colors for standard deviation values will saturate at std_range.  If not provided,</span>
<span class="sd">        this is set based on the standard deviation values to be plotted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Generate axes to plot into</span>
    <span class="n">n_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">priors</span><span class="o">.</span><span class="n">dists</span><span class="p">)</span>
    <span class="n">plot_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_modes</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n_modes</span><span class="p">)]</span>
    <span class="n">mn_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">plot_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_modes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">std_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">plot_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_modes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Determine the axes ratio of the images we will plot</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dim_sampling</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">dim_sampling</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Get the mean and standard deviation images</span>
    <span class="n">mn_imgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_image_from_fcn</span><span class="p">(</span><span class="n">torch_mod_to_fcn</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">mn_f</span><span class="p">),</span> <span class="n">dim_sampling</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">dists</span><span class="p">]</span>
    <span class="n">std_imgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_image_from_fcn</span><span class="p">(</span><span class="n">torch_mod_to_fcn</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">std_f</span><span class="p">),</span> <span class="n">dim_sampling</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">priors</span><span class="o">.</span><span class="n">dists</span><span class="p">]</span>

    <span class="c1"># Get the max absolute values for the images</span>
    <span class="k">if</span> <span class="n">mn_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mn_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="p">))</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">mn_imgs</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">std_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">std_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">std_imgs</span><span class="p">])</span>

    <span class="c1"># Plot means</span>
    <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="p">):</span>
        <span class="n">mn_im</span> <span class="o">=</span> <span class="n">mn_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">mn_imgs</span><span class="p">[</span><span class="n">m_i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;PiYG&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">mn_range</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">mn_range</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
        <span class="n">mn_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect_ratio</span><span class="p">)</span>
        <span class="n">mn_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mn_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m_i</span> <span class="o">==</span> <span class="n">n_modes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">mn_im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">mn_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">])</span>

    <span class="c1"># Plot standard deviations</span>
    <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="p">):</span>
        <span class="n">std_im</span> <span class="o">=</span> <span class="n">std_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">std_imgs</span><span class="p">[</span><span class="n">m_i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;cool&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">std_range</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
        <span class="n">std_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">std_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m_i</span> <span class="o">==</span> <span class="n">n_modes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">std_im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">std_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">])</span></div>


<div class="viewcode-block" id="plot_single_2d_mode"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.plot_single_2d_mode">[docs]</a><span class="k">def</span> <span class="nf">plot_single_2d_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">neuron_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vl_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">dim_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                  <span class="n">plot_axes</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_color_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plots the mode loadings for a single mode for neurons positioned in 2-d space.</span>

<span class="sd">    Args:</span>
<span class="sd">        mode: The mode to plot as a 1-d array of length n_neurons.</span>

<span class="sd">        neuron_p: The position of each neuron.  Shape is n_neurons*2.</span>

<span class="sd">        vl_range: The min and max value to clip values at when assigning colors.  If not provided, will be</span>
<span class="sd">        assigned based on the values in modes.</span>

<span class="sd">        dim_range: The spatial range to generate plots for.</span>

<span class="sd">        plot_axes: The axes to plot into.  If none, one will be provided</span>

<span class="sd">        plot_color_bar: True if a color bar should be added to the plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vl_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vl_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot_axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>

    <span class="c1"># Plot the mode</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">plot_axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">neuron_p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">neuron_p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                               <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;PiYG&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">vl_range</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vl_range</span><span class="p">)</span>

    <span class="n">plot_axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

    <span class="n">plot_axes</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_color_bar</span><span class="p">:</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_single_2d_mode_posterior"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.plot_single_2d_mode_posterior">[docs]</a><span class="k">def</span> <span class="nf">plot_single_2d_mode_posterior</span><span class="p">(</span><span class="n">post</span><span class="p">:</span> <span class="n">CondMatrixProductDistribution</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">neuron_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                  <span class="n">vl_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dim_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                  <span class="n">plot_axes</span><span class="p">:</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_mn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">plot_color_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plots the mean or standard deviation of mode loadings for a single mode for neurons positioned in 2-d space.</span>

<span class="sd">    The distribution can be transformed before plotting.</span>

<span class="sd">    Args:</span>
<span class="sd">        post: The posterior distribution over modes.</span>

<span class="sd">        mode: The index of the mode to plot the posterior over.</span>

<span class="sd">        neuron_p: The position of each neuron.  Shape is n_neurons*2.</span>

<span class="sd">        vl_range: The min and max value to clip values at when assigning colors.  If not provided, will be</span>
<span class="sd">        assigned based on the values in modes.</span>

<span class="sd">        dim_range: The spatial range to generate plots for.</span>

<span class="sd">        plot_axes: Axes to plot into.  If None, one will be created.</span>

<span class="sd">        plot_mn: If true, the mean is plotted.  If false, the standard deviation is plotted.</span>

<span class="sd">        t: The transition matrix to apply to the distribution if it should be transformed before plotting.</span>

<span class="sd">        plot_color_bar: True if a color bar should be added to the plot.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get means and standard deviations for unrotated modes</span>
    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">post</span><span class="p">(</span><span class="n">neuron_p</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">d</span><span class="p">(</span><span class="n">neuron_p</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">post</span><span class="o">.</span><span class="n">dists</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># Rotate modes</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_modes</span> <span class="o">=</span> <span class="n">mode_mn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_modes</span><span class="p">)</span>

    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mode_mn</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">mode_std</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Get the mode we are to plot</span>
    <span class="n">mode_mn</span> <span class="o">=</span> <span class="n">mode_mn</span><span class="p">[:,</span> <span class="n">mode</span><span class="p">]</span>
    <span class="n">mode_std</span> <span class="o">=</span> <span class="n">mode_std</span><span class="p">[:,</span> <span class="n">mode</span><span class="p">]</span>

    <span class="c1"># Plot either the mean or standard deviation</span>
    <span class="k">if</span> <span class="n">plot_mn</span><span class="p">:</span>
        <span class="n">mode_im</span> <span class="o">=</span> <span class="n">mode_mn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mode_im</span> <span class="o">=</span> <span class="n">mode_std</span>

    <span class="c1"># Get the max absolute values for the images</span>
    <span class="k">if</span> <span class="n">vl_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vl_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mode_im</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot_mn</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">vl_range</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PiYG&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;cool&#39;</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">vl_range</span>

    <span class="c1"># Plot the mode</span>
    <span class="k">if</span> <span class="n">plot_axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot_axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">plot_axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">neuron_p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">neuron_p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">mode_im</span><span class="p">,</span>
                               <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>

    <span class="n">plot_axes</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

    <span class="n">plot_axes</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plot_axes</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_color_bar</span><span class="p">:</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">sp</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_2d_modes"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.plot_2d_modes">[docs]</a><span class="k">def</span> <span class="nf">plot_2d_modes</span><span class="p">(</span><span class="n">modes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">neuron_p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vl_range</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">dim_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]):</span>
    <span class="sd">&quot;&quot;&quot; Plots the mode loadings for neurons positioned in a 2-d space.</span>

<span class="sd">    Modes will be plotted in a row, followed by a colorbar.  All modes will be plotted on the same color scale.</span>

<span class="sd">    Args:</span>
<span class="sd">        modes: The modes to plot as a n_neurons by n_modes array. Each column is a mode.</span>

<span class="sd">        neuron_p: The position of each neuron.  Shape is n_neurons*2.</span>

<span class="sd">        vl_range: The min and max value to clip values at when assigning colors.  If not provided, will be</span>
<span class="sd">        assigned based on the values in modes.</span>

<span class="sd">        dim_range: The spatial range to generate plots for.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_neurons</span><span class="p">,</span> <span class="n">n_modes</span> <span class="o">=</span> <span class="n">modes</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">vl_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vl_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">modes</span><span class="p">))</span>

    <span class="c1"># Plot images for each mode</span>
    <span class="n">mode_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_modes</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">m_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="p">):</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">neuron_p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">neuron_p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">modes</span><span class="p">[:,</span> <span class="n">m_i</span><span class="p">],</span>
                               <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;PiYG&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">vl_range</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vl_range</span><span class="p">)</span>
        <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">dim_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m_i</span> <span class="o">==</span> <span class="n">n_modes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Plot colorbar</span>
            <span class="n">cb</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">sp</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Make sure the colorbar axes are shaped as we want them</span>
            <span class="n">data_points</span> <span class="o">=</span> <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="n">cb_points</span> <span class="o">=</span> <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="n">cb_height</span> <span class="o">=</span> <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="p">]</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span><span class="o">.</span><span class="n">height</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="n">cb_points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">new_cb_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span>
                                        <span class="p">[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">cb_height</span><span class="o">*.</span><span class="mi">05</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">cb_height</span><span class="p">]])</span>
            <span class="n">new_cb_pos</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">Bbox</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">new_cb_points</span><span class="p">)</span>
            <span class="n">mode_axes</span><span class="p">[</span><span class="n">m_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">new_cb_pos</span><span class="p">)</span></div>


<div class="viewcode-block" id="learn_prior_transformation"><a class="viewcode-back" href="../../../../autoapi/janelia_core/ml/latent_regression/scenarios/index.html#janelia_core.ml.latent_regression.scenarios.learn_prior_transformation">[docs]</a><span class="k">def</span> <span class="nf">learn_prior_transformation</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">dim_sampling</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">01</span><span class="p">]],</span>
                               <span class="n">d0_slice</span><span class="p">:</span> <span class="nb">slice</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">d1_slice</span><span class="p">:</span> <span class="nb">slice</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Learns a transformation between two the means of two prior distributions.</span>

<span class="sd">    The transformation is learned based on sampling both conditional distributions.</span>

<span class="sd">    Args:</span>
<span class="sd">        d0: The distribution to transform *to*</span>

<span class="sd">        d1: The distribution to transform *from*</span>

<span class="sd">        dim_sampling: Each entry of dim_sampling specifies how to sample the conditional prior.  Each entry is</span>
<span class="sd">        of the form [start, stop, int] where start and and stop are the start and stop of the range of values to</span>
<span class="sd">        sample from and int is the interval values are sampled from.</span>

<span class="sd">        d0_slice: A slice indicating which modes of d0 to learn the transformation to.</span>

<span class="sd">        d1_slice: A slice indicating which modes of d1 to learn the transformation from.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Determine coordinates we will sample from along each dimension</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">dim_sampling</span><span class="p">]</span>

    <span class="c1"># Form coordinates of each point we will sample from in a single numpy array</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">n_pts</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">flat_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">n_pts</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">mn_0</span> <span class="o">=</span> <span class="n">d0</span><span class="p">(</span><span class="n">flat_grid</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">d0_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mn_0</span> <span class="o">=</span> <span class="n">mn_0</span><span class="p">[:,</span> <span class="n">d0_slice</span><span class="p">]</span>

    <span class="n">mn_1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">(</span><span class="n">flat_grid</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">d1_slice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mn_1</span> <span class="o">=</span> <span class="n">mn_1</span><span class="p">[:,</span> <span class="n">d1_slice</span><span class="p">]</span>

    <span class="n">solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">mn_1</span><span class="p">,</span> <span class="n">mn_0</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, William Bishop.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>