<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>janelia_core.stats.regression &mdash; janelia_core 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> janelia_core
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Setting up the core library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html#dependencies">Dependencies</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/janelia_core/index.html">janelia_core</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">janelia_core</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">janelia_core.stats.regression</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for janelia_core.stats.regression</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Tools for computing statistics in various ways when working with linear regression models.</span>

<span class="sd">The tools provided here are designed for use when assumptions underlying standard approaches to computing statistics</span>
<span class="sd">for linear regression models do not apply.  In particular, there are multiple methods for handling grouped errors as</span>
<span class="sd">well as methods for computing statistics via boostrap methods.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>


<div class="viewcode-block" id="corr"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.corr">[docs]</a><span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculates the pearson correlation between two series of data.</span>

<span class="sd">    If the data is multi-dimensional, the pearson correlation is calculated for each dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: One set of data of shape n_smps*n_dim</span>

<span class="sd">        y: The other set of data; same shape as x</span>

<span class="sd">    Returns:</span>
<span class="sd">        pearson_corr: The pearson correlation between x and y.  If x &amp; y are multidimensional, then pearson_corr</span>
<span class="sd">        is an array and pearson_corr[i] is the correlation for dimension i.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dims_expanded</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dims_expanded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">n_vars</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pearson_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_vars</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
        <span class="n">p_c</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">v_i</span><span class="p">],</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">v_i</span><span class="p">])</span>
        <span class="n">pearson_corr</span><span class="p">[</span><span class="n">v_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_c</span>

    <span class="k">if</span> <span class="n">dims_expanded</span><span class="p">:</span>
        <span class="n">pearson_corr</span> <span class="o">=</span> <span class="n">pearson_corr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">pearson_corr</span></div>


<div class="viewcode-block" id="normalized_r_squared"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.normalized_r_squared">[docs]</a><span class="k">def</span> <span class="nf">normalized_r_squared</span><span class="p">(</span><span class="n">truth</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes normalized r-squared for a collection of variables.</span>

<span class="sd">    Normalized r-squared is defined as follows:  1 - ( \sum r_i) / ( \sum s_i), where:</span>

<span class="sd">        r_i is the squared error between predictions and truth for variable i and s_i is the squared error</span>
<span class="sd">        of variable i between the mean value and truth.</span>

<span class="sd">    Normalized squared error is equal to standard r-squared when there is only one variable.  When there</span>
<span class="sd">    is more than one variable but all variables have the same variance, then normalized r-squared is equal</span>
<span class="sd">    to the average of the r-squared values for each individual variable.  However, when some variables have</span>
<span class="sd">    higher variance than others, normalized r-squared weights those with higher variance more than those with</span>
<span class="sd">    less variance.</span>

<span class="sd">    Args:</span>
<span class="sd">        truth: True data of shape n_smps*n_vars</span>

<span class="sd">        pred: Predicated data of shape n_smps*n_vars</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        norm_r_sq: The normlaized r-squared</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">true_mns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">truth</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">true_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">truth</span> <span class="o">-</span> <span class="n">true_mns</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">residual_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">truth</span> <span class="o">-</span> <span class="n">pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">residual_ss</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">true_ss</span><span class="p">)</span></div>


<div class="viewcode-block" id="r_squared"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.r_squared">[docs]</a><span class="k">def</span> <span class="nf">r_squared</span><span class="p">(</span><span class="n">truth</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes the r-squared value for a collection of variables.</span>

<span class="sd">    Computes the proportion of variance predicted variables capture of ground truth variables.</span>

<span class="sd">    Args:</span>
<span class="sd">        truth: True data of shape n_smps*n_vars</span>

<span class="sd">        pred: Predicated data of shape n_smps*n_vars</span>

<span class="sd">    Returns:</span>
<span class="sd">        r_sq: r_sq[i] contains the r-squared value for pred[:, i]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">pred</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">truth</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">true_mns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">truth</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">true_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">truth</span> <span class="o">-</span> <span class="n">true_mns</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">residual_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">truth</span> <span class="o">-</span> <span class="n">pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">r_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">residual_ss</span><span class="o">/</span><span class="n">true_ss</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r_sq</span></div>


<div class="viewcode-block" id="grouped_linear_regression_boot_strap"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_boot_strap">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_boot_strap</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n_bs_smps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">include_mean</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Fits a linear regression model, performing a grouped bootstrap to get confidence intervals on coefficients.</span>

<span class="sd">    By grouped bootstrap, we mean samples are selected in groups.</span>

<span class="sd">    This function returns the coefficients for each bootstrap sample.  Use grouped_linear_regression_boot_strap_stats</span>
<span class="sd">    to compute statistics (such as confidence intervals on the coefficients) and visualize_boot_strap_results to</span>
<span class="sd">    visualize a summary of the fit results.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: 1-d array of the predicted variable.  Of length n_smps.</span>

<span class="sd">        x: Variables to predict from.  Of shape n_smps*d_x.</span>

<span class="sd">        g: 1-d array indicating groups of samples.  Of length n_smps.  Samples from the same group should</span>
<span class="sd">        have the same value in g.</span>

<span class="sd">        n_bs_smps: The number of boot strap samples to draw</span>

<span class="sd">        include_mean: True if models should have a mean term included.  False if not.</span>

<span class="sd">        rcond: The value of rcond to provide to the least squares fitting.  See np.linalg.lstsq.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bs_beta: Of shape n_boot_strap_smps*n_coefs.  bs_beta[i,:] contains the coefficients of the linear regression</span>
<span class="sd">        model for the i^th bootstrap sample.  If include_mean is True, the last column of bs_beta contains the mean.</span>

<span class="sd">        beta: The beta fit to the data.  If include_mean is True, the last entry of bs_beta contains the mean.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_smps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="c1"># Determine where the groups are</span>
    <span class="n">grps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">n_grps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grps</span><span class="p">)</span>
    <span class="n">grp_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_grps</span>
    <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">grp_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grps</span><span class="p">):</span>
        <span class="n">grp_inds</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">grp_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Add term in x for mean</span>
    <span class="k">if</span> <span class="n">include_mean</span><span class="p">:</span>
        <span class="n">x_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">n_smps</span><span class="p">,</span> <span class="mi">1</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_aug</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Estimate beta</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">x_aug</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Perform bootstrap</span>
    <span class="n">bs_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_bs_smps</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">beta</span><span class="p">)])</span>

    <span class="k">for</span> <span class="n">b_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bs_smps</span><span class="p">):</span>

        <span class="c1"># Form sample</span>
        <span class="n">smp_grp_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_grps</span><span class="p">),</span> <span class="n">n_grps</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">bs_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">grp_inds</span><span class="p">[</span><span class="n">smp_g_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">smp_g_i</span> <span class="ow">in</span> <span class="n">smp_grp_inds</span><span class="p">])</span>

        <span class="n">bs_x_aug</span> <span class="o">=</span> <span class="n">x_aug</span><span class="p">[</span><span class="n">bs_inds</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">bs_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">bs_inds</span><span class="p">]</span>

        <span class="c1"># Estimate beta for bootstrap sample</span>
        <span class="n">beta_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">bs_x_aug</span><span class="p">,</span> <span class="n">bs_y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>
        <span class="n">bs_beta</span><span class="p">[</span><span class="n">b_i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">beta_est</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">bs_beta</span><span class="p">,</span> <span class="n">beta</span><span class="p">]</span></div>


<div class="viewcode-block" id="grouped_linear_regression_wild_bootstrap"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_wild_bootstrap">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_wild_bootstrap</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                             <span class="n">test_coefs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_bs_smps</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                             <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes a linear model and stats using a wild bootstrap.</span>

<span class="sd">    For group g, the model for the i^th observation is of the form:</span>

<span class="sd">        y_gi = x_gi^T\beta + o_g + \ep_gi,</span>

<span class="sd">    where x_gi are predictor variables of dimension P, o_g is a group offset and ep_gi is zero-mean noise.  In this</span>
<span class="sd">    model, it assumes all groups shared the same \beta but each group gets its own o_g and \ep_gi.</span>

<span class="sd">    This function will estimate beta as well as p-values that individual coefficients in beta are non-zero.</span>

<span class="sd">    The bootstrap procedure is based on the &quot;Wild Cluster bootstrap-t with H0 imposed&quot; bootstrap described in:</span>

<span class="sd">        &quot;Boostrap-based Improvements for Inference with Clustered Errors&quot;by Cameron, Gelback &amp; Miller, 2008</span>

<span class="sd">    Within each boostrap iteration, the standard-error needed for calculating Wald statistics is estimated with the</span>
<span class="sd">    within estimator of:</span>

<span class="sd">        &quot;Computing Robust Standard Errors for Within-groups Estimators&quot; by M. Arellano, 1987,</span>

<span class="sd">    where a small-sample correction is also applied as recommended in:</span>

<span class="sd">        &quot;A Practioner&#39;s Guide to Cluster-Robust Inference&quot; by A. Cameron and Douglas Miller, 2015.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: 1-d array of the predicted variable.  Of length n_smps.</span>

<span class="sd">        x: Variables to predict from.  Of shape n_smps*d_x.</span>

<span class="sd">        g: 1-d array indicating groups of samples.  Of length n_smps.  Samples from the same group should</span>
<span class="sd">        have the same value in g.</span>

<span class="sd">        test_coefs: If None, statistical significant that each individual entry in \beta is different than 0 will be</span>
<span class="sd">        calculated.  If not, this is a list of indices of beta to test for</span>

<span class="sd">        n_bs_smps: The number of bootstrap samples to use when calculating p-values.</span>

<span class="sd">        rcond: The value of rcond to provide to the least squares fitting within the call to</span>
<span class="sd">        grouped_linear_regression_within_estimator.  See that function as well np.linalg.lstsq.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p_vls: The computed p-values for rejecting the null hypothesis that each coefficient is 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_x_vars</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Determine where the groups are</span>
    <span class="n">grps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">n_grps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grps</span><span class="p">)</span>
    <span class="n">grp_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_grps</span>
    <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">grp_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grps</span><span class="p">):</span>
        <span class="n">grp_inds</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">grp_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Compute beta</span>
    <span class="n">beta</span><span class="p">,</span> <span class="n">avm</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">grouped_linear_regression_within_estimator</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>

    <span class="c1"># Calculate p-values that each individual coefficient in beta is different than 0</span>
    <span class="k">if</span> <span class="n">test_coefs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">test_coefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_x_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">coef_p_vl_bs</span><span class="p">(</span><span class="n">coef_i</span><span class="p">,</span> <span class="n">null_vl</span><span class="p">,</span> <span class="n">n_bs_smps</span><span class="p">):</span>

        <span class="c1"># Compute wald statistic for the observed data</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">coef_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">null_vl</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avm</span><span class="p">[</span><span class="n">coef_i</span><span class="p">,</span> <span class="n">coef_i</span><span class="p">])</span>

        <span class="c1"># Construct the beta for the null hypothesis</span>
        <span class="n">null_beta</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">null_beta</span><span class="p">[</span><span class="n">coef_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">null_vl</span>

        <span class="c1"># Calculate residuals under this null hypothesis</span>
        <span class="n">null_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">null_beta</span><span class="p">)</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">null_pred</span>

        <span class="c1"># Get bootstrap samples from distribution of the wald statistic under the null</span>
        <span class="n">w_bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bs_smps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bs_smps</span><span class="p">):</span>

            <span class="n">grp_signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">n_grps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">g_inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grp_inds</span><span class="p">):</span>
                <span class="n">residuals</span><span class="p">[</span><span class="n">g_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">grp_signs</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span><span class="o">*</span><span class="n">residuals</span><span class="p">[</span><span class="n">g_inds</span><span class="p">]</span>
            <span class="n">y_bs</span> <span class="o">=</span> <span class="n">residuals</span> <span class="o">+</span> <span class="n">null_pred</span>
            <span class="n">beta_bs</span><span class="p">,</span> <span class="n">avm_bs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">grouped_linear_regression_within_estimator</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y_bs</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>
            <span class="n">w_bs</span><span class="p">[</span><span class="n">b_i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta_bs</span><span class="p">[</span><span class="n">coef_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">null_vl</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avm_bs</span><span class="p">[</span><span class="n">coef_i</span><span class="p">,</span> <span class="n">coef_i</span><span class="p">])</span>

        <span class="c1"># Calculate p-value</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_bs</span><span class="p">))</span><span class="o">/</span><span class="n">n_bs_smps</span>

    <span class="n">p_vls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_coefs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">coef_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_coefs</span><span class="p">):</span>
        <span class="n">p_vls</span><span class="p">[</span><span class="n">c_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef_p_vl_bs</span><span class="p">(</span><span class="n">coef_i</span><span class="o">=</span><span class="n">coef_i</span><span class="p">,</span> <span class="n">null_vl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_bs_smps</span><span class="o">=</span><span class="n">n_bs_smps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p_vls</span></div>


<div class="viewcode-block" id="grouped_linear_regression_ols_estimator"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_ols_estimator">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_ols_estimator</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                            <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Fits a linear model and stats using optimal least squares, accounting for grouped errors.</span>

<span class="sd">     For group g, the model for the i^th observation is of the form:</span>

<span class="sd">        y_gi = x_gi^T\beta + \ep_gi,</span>

<span class="sd">    where x_gi are predictor variables of dimension P, and ep_gi is noise.  In this model, it assumes all groups shared</span>
<span class="sd">    the same \beta but each group gets its own \ep_gi.</span>

<span class="sd">    Note: A small sample correction is applied when calculating the asymptotic covariance matrix, as outlined in</span>

<span class="sd">        &quot;A Practioner&#39;s Guide to Cluster-Robust Inference&quot; by A. Cameron and Douglas Miller, 2015.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: 1-d array of the predicted variable.  Of length n_smps.</span>

<span class="sd">        x: Variables to predict from.  Of shape n_smps*d_x.</span>

<span class="sd">        g: 1-d array indicating groups of samples.  Of length n_smps.  Samples from the same group should</span>
<span class="sd">        have the same value in g.</span>

<span class="sd">        rcond: The value of rcond to provide to the least squares fitting.  See np.linalg.lstsq.</span>

<span class="sd">    Returns:</span>
<span class="sd">        beta: The estimate of beta</span>

<span class="sd">        acm: The asymptotic covariance matrix for beta.</span>

<span class="sd">        n_grps: The number of groups in the analysis</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of samples does not exceed the number of x variables.</span>
<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">n_smps</span><span class="p">,</span> <span class="n">n_x_vars</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">n_x_vars</span> <span class="o">&gt;=</span> <span class="n">n_smps</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of samples does not exceed number of x variables.&#39;</span><span class="p">))</span>

    <span class="c1"># Determine where the groups are</span>
    <span class="n">grps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">n_grps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grps</span><span class="p">)</span>
    <span class="n">grp_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_grps</span>
    <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">grp_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grps</span><span class="p">):</span>
        <span class="n">grp_inds</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">grp_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate beta</span>
    <span class="n">beta_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">beta_est</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate asymptotic covariance matrix</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_grps</span><span class="o">/</span><span class="p">(</span><span class="n">n_grps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">n_smps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n_smps</span> <span class="o">-</span> <span class="n">n_x_vars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">m0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_x_vars</span><span class="p">,</span> <span class="n">n_x_vars</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">grp_inds</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">residual</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

    <span class="n">acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">),</span> <span class="n">m0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">beta</span><span class="p">,</span> <span class="n">acm</span><span class="p">,</span> <span class="n">n_grps</span><span class="p">]</span></div>


<div class="viewcode-block" id="grouped_linear_regression_within_estimator"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_within_estimator">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_within_estimator</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                               <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes linear model and stats using the within estimator for a fixed-effects linear model.</span>

<span class="sd">    For group g, the model for the i^th observation is of the form:</span>

<span class="sd">        y_gi = x_gi^T\beta + o_g + \ep_gi,</span>

<span class="sd">    where x_gi are predictor variables of dimension P, o_g is a group offset and ep_gi is zero-mean noise.  In this model,</span>
<span class="sd">    it assumes all groups shared the same \beta but each group gets its own o_g and \ep_gi.</span>

<span class="sd">    This function will estimate beta as well as the asymptotic covariance matrix for beta using the method of:</span>

<span class="sd">        &quot;Computing Robust Standard Errors for Within-groups Estimators&quot; by M. Arellano, 1987.</span>

<span class="sd">    It will then apply a finite sample correction as recommended in:</span>

<span class="sd">        &quot;A Practioner&#39;s Guide to Cluster-Robust Inference&quot; by A. Cameron and Douglas Miller, 2015.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: 1-d array of the predicted variable.  Of length n_smps.</span>

<span class="sd">        x: Variables to predict from.  Of shape n_smps*d_x.</span>

<span class="sd">        g: 1-d array indicating groups of samples.  Of length n_smps.  Samples from the same group should</span>
<span class="sd">        have the same value in g.</span>

<span class="sd">        rcond: The value of rcond to provide to the least squares fitting.  See np.linalg.lstsq.</span>

<span class="sd">    Returns:</span>
<span class="sd">        beta: The estimate of beta</span>

<span class="sd">        acm: The asymptotic covariance matrix for beta.</span>

<span class="sd">        offsets: A dictionary with the o_g values for each group.  Keys will be values of g used to indicate groups and</span>
<span class="sd">        values will be the offset for each group.</span>

<span class="sd">        n_grps: The number of groups in the analysis</span>
<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">n_smps</span><span class="p">,</span> <span class="n">n_x_vars</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Determine where the groups are</span>
    <span class="n">grps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">n_grps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grps</span><span class="p">)</span>
    <span class="n">grp_inds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_grps</span>
    <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">grp_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grps</span><span class="p">):</span>
        <span class="n">grp_inds</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">grp_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Mean center x and y</span>
    <span class="n">x_ctr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y_ctr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">grp_inds</span><span class="p">:</span>
        <span class="n">x_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">x_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>

    <span class="c1"># Calculate beta</span>
    <span class="n">beta_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">x_ctr</span><span class="p">,</span> <span class="n">y_ctr</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">beta_est</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate the asymptotic variance matrix for beta</span>
    <span class="n">residual</span> <span class="o">=</span> <span class="n">y_ctr</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x_ctr</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_grps</span><span class="o">/</span><span class="p">(</span><span class="n">n_grps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">n_smps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n_smps</span> <span class="o">-</span> <span class="n">n_x_vars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># Correction factor for finite samples</span>

    <span class="n">m0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x_ctr</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">x_ctr</span><span class="p">))</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_x_vars</span><span class="p">,</span> <span class="n">n_x_vars</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">grp_inds</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x_ctr</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">residual</span><span class="p">[</span><span class="n">inds</span><span class="p">])</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;m0&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;m1&#39;</span><span class="p">)</span>

    <span class="n">acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">m1</span><span class="p">),</span> <span class="n">m0</span><span class="p">)</span>

    <span class="c1"># Calculate offsets for each group</span>
    <span class="n">uncentered_res</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">o_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_grps</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">g_i</span><span class="p">,</span> <span class="n">g_inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grp_inds</span><span class="p">):</span>
        <span class="n">o_g</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">uncentered_res</span><span class="p">[</span><span class="n">g_inds</span><span class="p">])</span>

    <span class="n">offsets</span> <span class="o">=</span> <span class="p">{</span><span class="n">g</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">grps</span><span class="p">,</span> <span class="n">o_g</span><span class="p">)}</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">beta</span><span class="p">,</span> <span class="n">acm</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">n_grps</span><span class="p">]</span></div>


<div class="viewcode-block" id="grouped_linear_regression_acm_stats"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_acm_stats">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_acm_stats</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">acm</span><span class="p">,</span> <span class="n">n_grps</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculates statistics given an estimate of an asymptotic covariance matrix.</span>

<span class="sd">    Confidence intervals and p-values for individual coefficients are calculated assuming a t-distribution on the</span>
<span class="sd">    estimates for the individual entries of beta.</span>

<span class="sd">    Args:</span>
<span class="sd">        beta: The estimate of beta</span>

<span class="sd">        acm: The asymptotic variance matrix for beta</span>

<span class="sd">        n_grps: The number of groups in the original regression</span>

<span class="sd">        alpha: The alpha value to use when constructing 1-alpha confidence intervals</span>

<span class="sd">    Returns:</span>
<span class="sd">        stats: A dictionary with the following keys:</span>

<span class="sd">            alpha: The alpha value for which confidence intervals were calculated.</span>

<span class="sd">            c_ints: Confidence intervals.  c_ints[:,i] is the 1-alpha percentile confidence interval for beta[i]</span>

<span class="sd">            non_zero_p: Indicates the p-value for null hypothesis that beta[i] is 0.</span>

<span class="sd">            non_zero: non_zero[i] is true if the confidence interval for beta[i] does not contain 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="p">(</span><span class="n">n_grps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">std_ers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">acm</span><span class="p">))</span>

    <span class="n">c_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">beta</span> <span class="o">-</span> <span class="n">std_ers</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">beta</span><span class="o">+</span><span class="n">std_ers</span><span class="o">*</span><span class="n">m</span><span class="p">])</span>

    <span class="n">non_zero_p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="p">(</span><span class="n">n_grps</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beta</span><span class="o">/</span><span class="n">std_ers</span><span class="p">))</span>

    <span class="n">non_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">c_ints</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c_ints</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;c_ints&#39;</span><span class="p">:</span> <span class="n">c_ints</span><span class="p">,</span> <span class="s1">&#39;non_zero_p&#39;</span><span class="p">:</span> <span class="n">non_zero_p</span><span class="p">,</span> <span class="s1">&#39;non_zero&#39;</span><span class="p">:</span> <span class="n">non_zero</span><span class="p">}</span></div>


<div class="viewcode-block" id="grouped_linear_regression_acm_linear_restriction_stats"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_acm_linear_restriction_stats">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_acm_linear_restriction_stats</span><span class="p">(</span><span class="n">beta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">acm</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                           <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n_grps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Given an asymptotic covariance matrix from linear regression, tests significance of linear restrictions.</span>

<span class="sd">    Given a vector of K-coefficients, beta, we desire to produce a p-value for a null hypothesis taking the form of</span>
<span class="sd">    J linear restrictions, which can be written as:</span>

<span class="sd">    r*beta = q, where r is a matrix of size J by K and q is a vector of length J.</span>

<span class="sd">    This function was based heavily on chapter 5 of Greene, Econometric Analysis.  In addition, to this</span>
<span class="sd">    reference a good reference on Wald tests (the Wikipedia article is not a bad place to start) may also be</span>
<span class="sd">    useful.</span>

<span class="sd">    The basic approach we take here is we assume:</span>

<span class="sd">    1) The distribution on beta is well approximated as a normal distribution with the asymptotic covariance matrix</span>
<span class="sd">    provided to this function.</span>

<span class="sd">    2) Under this assumption, we can compute the F-statistic (see Greene), which is defined as:</span>

<span class="sd">        F = [r*beta - q]&#39; (r&#39; * acm * r)^{-1} [r*beta - q]/J,</span>

<span class="sd">        which has a distribution equal to 1/J times a Chi-squared distribution with K degrees of freedom.</span>

<span class="sd">    3) We can in principle calculate critical values comparing F*J to critical values from a Chi-square distribution.</span>
<span class="sd">    However, again following Greene, we choose to use critical values from the F-distribution, which is more</span>
<span class="sd">    conservative.  Specifically, we compare F (no need now to multiply by J) to the critical values from the</span>
<span class="sd">    F(J, n_grps - K) distribution.</span>

<span class="sd">    Note: This function can be used for computing statistics for linear restrictions of non-grouped results as well.</span>
<span class="sd">    In this case, n_grps should just be seq equal to the number of samples in the data.</span>

<span class="sd">    Args:</span>
<span class="sd">        beta: The beta vector which was estimated</span>

<span class="sd">        acm: The estimated asymptotic covariance matrix</span>

<span class="sd">        r: The r matrix for linear restrictions.  Each row is a restriction.</span>

<span class="sd">        q: The q vector for linear restrictions.</span>

<span class="sd">        n_grps: The number of groups in the original data</span>

<span class="sd">    Returns:</span>
<span class="sd">        p: The calculated p value.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Expand beta</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Make sure r is always 2-d, even if user only gave one linear restriction.</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Make sure q is always a vector</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">q</span>
    <span class="n">test_acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">acm</span><span class="p">),</span> <span class="n">r</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">test_acm</span><span class="p">)),</span> <span class="n">diff</span><span class="p">)</span><span class="o">/</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">n_grps</span> <span class="o">-</span> <span class="n">K</span><span class="p">)</span></div>


<div class="viewcode-block" id="naive_regression"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.naive_regression">[docs]</a><span class="k">def</span> <span class="nf">naive_regression</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Performs &quot;naive&quot; regression to predict x from y.</span>

<span class="sd">    By naive regression, we assume that all x variables are mutually independent. The parameters this</span>
<span class="sd">    function provides is the correct regression model for this case.  If not all variables are</span>
<span class="sd">    independent, the parameters returned by this function are sub-optimal.</span>

<span class="sd">    This function will return the parameters, b (a matrix) and o (a vector of offsets) to predict:</span>

<span class="sd">    y_i = x_i^T*b + o</span>

<span class="sd">    where we asume y_i \in R^m and x_i \in R^p.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: Data to predict of shape [n_smps, m]</span>

<span class="sd">        x: Data to predict from of shape [n_smps, p]</span>

<span class="sd">    Returns:</span>
<span class="sd">        b: the b matrix above</span>

<span class="sd">        o: the offset vector above</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x and y must be 2-d arrays&#39;</span><span class="p">))</span>

    <span class="n">n_smps</span><span class="p">,</span> <span class="n">n_x_vars</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_y_vars</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Calculate means</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">y_mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">x_ctr</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mu</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_x_vars</span><span class="p">,</span> <span class="n">n_y_vars</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_y_vars</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[:,</span> <span class="n">v_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span><span class="p">[:,</span> <span class="n">v_i</span><span class="p">:</span><span class="n">v_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x_ctr</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">var</span><span class="o">*</span><span class="n">n_smps</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">o</span> <span class="o">=</span> <span class="n">y_mn</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">mu</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span></div>


<div class="viewcode-block" id="visualize_boot_strap_results"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.visualize_boot_strap_results">[docs]</a><span class="k">def</span> <span class="nf">visualize_boot_strap_results</span><span class="p">(</span><span class="n">bs_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">var_strs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">var_clrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">violin_plots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="n">plot_c_ints</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">show_nz_sig</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="n">plot_zero_line</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">.05</span><span class="p">,</span> <span class="n">theta_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                 <span class="n">er_bar_pts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sig_size</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sig_y_vl</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">ax</span><span class="p">:</span><span class="n">plt</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; For visualizing the results of grouped_linear_regression_boot_strap.</span>

<span class="sd">    Args:</span>
<span class="sd">        bs_values: The coefficients for each bootstrap sample. bs_values[i,:] are the coefficients for bootstrap sample</span>
<span class="sd">        i.</span>

<span class="sd">        var_strs: The names of each of the coefficients in bs_values.</span>

<span class="sd">        theta: Point estimates for each coefficient.  If None, point values will not be plotted.</span>

<span class="sd">        var_clrs: Of shape n_coefs*3.  var_clrs[i,:] is a color for plotting the values associated with coefficient i.</span>

<span class="sd">        violin_plots: If true, violin plots of coefficient values will be plotted.</span>

<span class="sd">        plot_c_ints: True if confidence intervals for each coefficient should be plotted.</span>

<span class="sd">        plot_zero_line: True if a dotted line denoting 0 should be added to the plot.</span>

<span class="sd">        show_nz_sig: True if coefficients significantly different than 0 should be denoted with stars. This is</span>
<span class="sd">        computed simply by testing if the confidence interval for a coefficient contains 0.</span>

<span class="sd">        alpha: The alpha value for constructing confidence intervals and determining if coefficients are significantly</span>
<span class="sd">        different than 0.</span>

<span class="sd">        theta_size: The size of the marker to use when plotting point estimages of coefficients.</span>

<span class="sd">        er_bar_pts: The width of error bars to plot for confidence intervals.</span>

<span class="sd">        sig_size: The size of the marker to use when denoting which coefficients are significanly different 0.</span>

<span class="sd">        sig_y_vl: If not None, this is the y-value used for showing significant stars.</span>

<span class="sd">        ax: The axis to plot into.  If none, one will be created.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ax: The axes the plot was created in</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_strs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">var_clrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_clrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_vars</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

    <span class="c1"># Create violin plots if we are suppose to</span>
    <span class="k">if</span> <span class="n">violin_plots</span><span class="p">:</span>
        <span class="n">vp_parts</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">bs_values</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vp_parts</span><span class="p">[</span><span class="s1">&#39;bodies&#39;</span><span class="p">]):</span>
            <span class="n">body</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">var_i</span><span class="p">,</span> <span class="p">:])</span>

    <span class="c1"># Label x-axis</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">var_strs</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=-</span><span class="mi">75</span><span class="p">)</span>

    <span class="c1"># Set colors of x-axis labels</span>
    <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">x_lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()):</span>
        <span class="n">x_lbl</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">var_i</span><span class="p">,</span> <span class="p">:])</span>

    <span class="c1"># Plot zero line if we are suppose to</span>
    <span class="k">if</span> <span class="n">plot_zero_line</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>

    <span class="c1"># Plot statistics if we are suppose to</span>
    <span class="k">if</span> <span class="n">plot_c_ints</span> <span class="ow">or</span> <span class="n">show_nz_sig</span><span class="p">:</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">grouped_linear_regression_boot_strap_stats</span><span class="p">(</span><span class="n">bs_values</span><span class="o">=</span><span class="n">bs_values</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_c_ints</span><span class="p">:</span>
            <span class="n">err_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;c_ints&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">lower_err_bars</span> <span class="o">=</span> <span class="n">err_y</span> <span class="o">-</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;c_ints&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">upper_err_bars</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;c_ints&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">err_y</span>
            <span class="n">err_bars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">lower_err_bars</span><span class="p">,</span> <span class="n">upper_err_bars</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">v_i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">err_y</span><span class="p">[</span><span class="n">v_i</span><span class="p">],</span> <span class="n">yerr</span><span class="o">=</span><span class="n">err_bars</span><span class="p">[:,</span> <span class="n">v_i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                            <span class="n">ecolor</span><span class="o">=</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">v_i</span><span class="p">,:],</span> <span class="n">elinewidth</span><span class="o">=</span><span class="n">er_bar_pts</span><span class="p">,</span>
                            <span class="n">capsize</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">er_bar_pts</span><span class="p">,</span> <span class="n">capthick</span><span class="o">=</span><span class="n">er_bar_pts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_nz_sig</span><span class="p">:</span>
            <span class="n">y_lim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">sig_y_vl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sig_y_vl</span> <span class="o">=</span> <span class="mf">.02</span><span class="o">*</span><span class="p">(</span><span class="n">y_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">y_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;non_zero&#39;</span><span class="p">][</span><span class="n">v_i</span><span class="p">]:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">v_i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sig_y_vl</span><span class="p">,</span> <span class="s1">&#39;k*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">sig_size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">v_i</span><span class="p">,:])</span>

    <span class="c1"># Show estimated point values</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">v_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="n">v_i</span><span class="p">],</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">theta_size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">v_i</span><span class="p">,:])</span>

    <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="grouped_linear_regression_boot_strap_stats"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.grouped_linear_regression_boot_strap_stats">[docs]</a><span class="k">def</span> <span class="nf">grouped_linear_regression_boot_strap_stats</span><span class="p">(</span><span class="n">bs_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span><span class="mf">.05</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; For getting statistics from the results of grouped_linear_regression_boot_strap.</span>

<span class="sd">    This function will compute:</span>

<span class="sd">        1) Confidence intervals for each coefficient.  Currently percentile confidence intervals are computed. See</span>
<span class="sd">        &quot;All of Statistics&quot; by Wasserman for more information on percentile confidence intervals for the bootstrap.</span>

<span class="sd">        2) P-values that coefficients are significantly different than 0, based on inverting percentile confidence</span>
<span class="sd">        intervals</span>

<span class="sd">    Args:</span>
<span class="sd">        bs_values: The results of grouped_linear_regresson_boot_strap.  bs_vls[i,:] are the coefficient for</span>
<span class="sd">        the i^th bootstrap sample.</span>

<span class="sd">        alpha: The alpha values to use when computing confidence intervals</span>

<span class="sd">    Returns:</span>
<span class="sd">        stats: A dictionary with the following keys:</span>

<span class="sd">            alpha: The alpha value for which confidence intervals were calculated.</span>

<span class="sd">            c_ints: Confidence intervals.  c_ints[:,i] is the 1-alpha percentile confidence interval for coefficient i.</span>

<span class="sd">            non_zero_p: Indicates the p-value for null hypothesis that the coefficient is 0.</span>

<span class="sd">            non_zero: Indicates coefficients with 1-alpha confidence intervals which do not contain 0.  non_zero[i] is</span>
<span class="sd">            true if the confidence interval for coefficient i does not contain 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Calculate percentile confidence intervals</span>
    <span class="n">n_smps</span><span class="p">,</span> <span class="n">n_coefs</span> <span class="o">=</span> <span class="n">bs_values</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">c_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_coefs</span><span class="p">])</span>
    <span class="n">c_ints</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_values</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">100</span><span class="o">*</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">c_ints</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_values</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># See which confidence intervals do not contain zero</span>
    <span class="n">non_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">c_ints</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c_ints</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># =============================================================================================</span>
    <span class="c1"># Calculate p-values</span>
    <span class="c1"># =============================================================================================</span>

    <span class="c1"># Find smallest values greater than 0 for each coefficient</span>
    <span class="n">sm_search_vls</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">bs_values</span><span class="p">)</span>
    <span class="n">sm_search_vls</span><span class="p">[</span><span class="n">sm_search_vls</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">sm_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sm_search_vls</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Find largest value less than 0 for each coefficient</span>
    <span class="n">lg_search_values</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">bs_values</span><span class="p">)</span>
    <span class="n">lg_search_values</span><span class="p">[</span><span class="n">lg_search_values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">lg_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lg_search_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Get percentage of entries larger and smaller than values above</span>
    <span class="n">sm_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bs_values</span> <span class="o">&lt;=</span> <span class="n">sm_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">n_smps</span>
    <span class="n">lg_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bs_values</span> <span class="o">&gt;=</span> <span class="n">lg_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">n_smps</span>

    <span class="n">non_zero_p</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">sm_p</span><span class="p">,</span> <span class="n">lg_p</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Return results</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;c_ints&#39;</span><span class="p">:</span> <span class="n">c_ints</span><span class="p">,</span> <span class="s1">&#39;non_zero_p&#39;</span><span class="p">:</span> <span class="n">non_zero_p</span><span class="p">,</span> <span class="s1">&#39;non_zero&#39;</span><span class="p">:</span> <span class="n">non_zero</span><span class="p">}</span></div>


<div class="viewcode-block" id="linear_regression_ols_estimator"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.linear_regression_ols_estimator">[docs]</a><span class="k">def</span> <span class="nf">linear_regression_ols_estimator</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">rcond</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Fits a linear model and stats using optimal least squares.</span>

<span class="sd">     For group g, the model for the i^th observation is of the form:</span>

<span class="sd">        y_i = x_i^T\beta + \ep_i,</span>

<span class="sd">    where x_i are predictor variables of dimension P, and ep_i is noise with a fixed variance.</span>

<span class="sd">    This function is based on chapter 4 of Greene, Econometric Analysis.</span>

<span class="sd">    Args:</span>
<span class="sd">        y: 1-d array of the predicted variable.  Of length n_smps.</span>

<span class="sd">        x: Variables to predict from.  Of shape n_smps*d_x.</span>

<span class="sd">        rcond: The value of rcond to provide to the least squares fitting.  See np.linalg.lstsq.</span>

<span class="sd">    Returns:</span>
<span class="sd">        beta: The estimate of beta</span>

<span class="sd">        acm: The asymptotic covariance matrix for beta.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of samples does not exceed the number of x variables.</span>
<span class="sd">   &quot;&quot;&quot;</span>

    <span class="n">n_smps</span><span class="p">,</span> <span class="n">n_x_vars</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">n_x_vars</span> <span class="o">&gt;=</span> <span class="n">n_smps</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of samples does not exceed number of x variables.&#39;</span><span class="p">))</span>

    <span class="c1"># Calculate beta</span>
    <span class="n">beta_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">beta_est</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate the asymptotic variance matrix</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>  <span class="c1"># This is actually 1/n * Q</span>
    <span class="n">er</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">s_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">er</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n_smps</span> <span class="o">-</span> <span class="n">n_x_vars</span><span class="p">)</span>

    <span class="n">acm</span> <span class="o">=</span> <span class="n">s_sq</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">beta</span><span class="p">,</span> <span class="n">acm</span></div>


<div class="viewcode-block" id="visualize_coefficient_stats"><a class="viewcode-back" href="../../../autoapi/janelia_core/stats/regression/index.html#janelia_core.stats.regression.visualize_coefficient_stats">[docs]</a><span class="k">def</span> <span class="nf">visualize_coefficient_stats</span><span class="p">(</span><span class="n">var_strs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">c_ints</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">var_clrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">er_bar_pts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">theta_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                <span class="n">sig_size</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sig_y_vl</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">x_axis_rot</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">75</span><span class="p">,</span>
                                <span class="n">ax</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">plot_zero_line</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; For visualizing estimated coefficients with confidence intervals.</span>

<span class="sd">    Args:</span>
<span class="sd">        var_strs: Strings giving the name of each coefficient</span>

<span class="sd">        theta: Point estimate for each coefficient, order corresponds to var_strs.  If None, point estimates will</span>
<span class="sd">        not be plotted.</span>

<span class="sd">        c_ints: c_ints[i,:] is the lower (left column) and upper (right column) limits on the confidence interval</span>
<span class="sd">        for the coefficient in var_strs[i].  If None, confidencce intervals will not be plotted.</span>

<span class="sd">        var_clrs: var_clrs[i,:] is the color to use for plotting the coefficient for var_strs[i].  If None, black</span>
<span class="sd">        will be used for all plotting.</span>

<span class="sd">        sig: sig[i] is True if the coefficient for var_strs[i] is significant. Significant values will have a</span>
<span class="sd">        star plotted to indicate they are significant.</span>

<span class="sd">        theta_size: The size of the marker to use when plotting point estimages of coefficients.</span>

<span class="sd">        er_bar_pts: The width of error bars to plot for confidence intervals.</span>

<span class="sd">        sig_size: The size of the marker to use when denoting which coefficients are significanly different 0.</span>

<span class="sd">        sig_y_vl: If not None, this is the y-value used for showing significant stars.</span>

<span class="sd">        plot_zero_line: True if a line indicating 0 should be plotted</span>

<span class="sd">        x_axis_rot: Rotation in degrees of x-axis labels.</span>

<span class="sd">        ax: Axes to plot into. If None, a new figure with axes will be created.</span>

<span class="sd">    Returns:</span>
<span class="sd">        as: The axes the plot was generated in.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_strs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">var_clrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_clrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_vars</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

    <span class="c1"># Label x-axis</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">var_strs</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">x_axis_rot</span><span class="p">)</span>

    <span class="c1"># Set colors of x-axis labels</span>
    <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">x_lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">()):</span>
        <span class="n">x_lbl</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">var_i</span><span class="p">,</span> <span class="p">:])</span>

    <span class="c1"># Plot zero line if we are suppose to</span>
    <span class="k">if</span> <span class="n">plot_zero_line</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>

    <span class="c1"># Plot confidence intervals if we are suppose to</span>
    <span class="k">if</span> <span class="n">c_ints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">err_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c_ints</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">lower_err_bars</span> <span class="o">=</span> <span class="n">err_y</span> <span class="o">-</span> <span class="n">c_ints</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">upper_err_bars</span> <span class="o">=</span> <span class="n">c_ints</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">err_y</span>
        <span class="n">err_bars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">lower_err_bars</span><span class="p">,</span> <span class="n">upper_err_bars</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">v_i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">err_y</span><span class="p">[</span><span class="n">v_i</span><span class="p">],</span> <span class="n">yerr</span><span class="o">=</span><span class="n">err_bars</span><span class="p">[:,</span> <span class="n">v_i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                        <span class="n">ecolor</span><span class="o">=</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">v_i</span><span class="p">,:],</span> <span class="n">elinewidth</span><span class="o">=</span><span class="n">er_bar_pts</span><span class="p">,</span>
                        <span class="n">capsize</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">er_bar_pts</span><span class="p">,</span> <span class="n">capthick</span><span class="o">=</span><span class="n">er_bar_pts</span><span class="p">)</span>

    <span class="c1"># Show estimated point values if we are suppose to</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">v_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">[</span><span class="n">v_i</span><span class="p">],</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">theta_size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">v_i</span><span class="p">,:])</span>

    <span class="c1"># Add asteriks to indicate significant if we are suppose to</span>
    <span class="k">if</span> <span class="n">sig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y_lim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sig_y_vl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sig_y_vl</span> <span class="o">=</span> <span class="mf">.02</span><span class="o">*</span><span class="p">(</span><span class="n">y_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">y_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="n">v_i</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">v_i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">sig_y_vl</span><span class="p">,</span> <span class="s1">&#39;k*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">sig_size</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">var_clrs</span><span class="p">[</span><span class="n">v_i</span><span class="p">,:])</span>

    <span class="k">return</span> <span class="n">ax</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, William Bishop.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>