<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>janelia_core.visualization.image_generation &mdash; janelia_core 1.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> janelia_core
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Setting up the core library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html#dependencies">Dependencies</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/janelia_core/index.html">janelia_core</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">janelia_core</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>janelia_core.visualization.image_generation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for janelia_core.visualization.image_generation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Tools for generating images.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">ImageDraw</span>

<span class="kn">from</span> <span class="nn">janelia_core.math.basic_functions</span> <span class="kn">import</span> <span class="n">list_grid_pts</span>


<div class="viewcode-block" id="alpha_composite"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.alpha_composite">[docs]</a><span class="k">def</span> <span class="nf">alpha_composite</span><span class="p">(</span><span class="n">dest</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">src</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Performs alpha compositing with two RGBA images with alpha-premultiplicaiton applied.</span>

<span class="sd">    All values should be floating point in the range 0 - 1.</span>

<span class="sd">    Standard RGBA values of the form [R_s, G_s, B_s, A_s] can be converted to a</span>
<span class="sd">    pre-multiplied RGBA value as [R_s*A_s, G_s*A_s, B_s*A_s, A_s].</span>

<span class="sd">    Good notes can be found at: https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Alpha_compositing.html</span>

<span class="sd">    Args:</span>
<span class="sd">        dest: The bottom image of shape d_x*d_y*4</span>

<span class="sd">        src: The top image.  Must be of the same shape as dest_img.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Nothing.  The dest array will be modified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">src_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">src</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dest</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">src</span> <span class="o">+</span> <span class="n">dest</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">src_alpha</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_2d_fcn_image"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.generate_2d_fcn_image">[docs]</a><span class="k">def</span> <span class="nf">generate_2d_fcn_image</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">dim_0_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dim_1_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">n_pts_per_dim</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">vis_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot; Generates an image of a 2d function.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: The function to visualize. Should accept input of shape [n by 2], where n is an arbitrary number</span>
<span class="sd">        of values and output values of length n.</span>

<span class="sd">        dim_0_range: The range of dim 0 values to visualize the function over.  If None, [0.0, 1.0] will be used.</span>

<span class="sd">        dim_1_range: The range of dim 1 values to visualize the function over.  If None, [0.0, 1.0] will be used.</span>

<span class="sd">        n_pts_per_dim: The number of points to sample per dimension.</span>

<span class="sd">        vis_dim: If f produces multiple dimension output, this is the dimension to visualize</span>

<span class="sd">    Returns:</span>
<span class="sd">        im: The image of the function as a 2-d numpy array</span>

<span class="sd">        dim_0_pts: The sampled points along dim 0</span>

<span class="sd">        dim_1_pts: The sampled points along dim 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dim_0_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dim_0_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dim_1_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dim_1_range</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n_pts_per_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_pts_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]</span>

    <span class="n">pts</span><span class="p">,</span> <span class="n">dim_pts</span> <span class="o">=</span> <span class="n">list_grid_pts</span><span class="p">(</span><span class="n">grid_limits</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">dim_0_range</span><span class="p">,</span> <span class="n">dim_1_range</span><span class="p">]),</span>
                                 <span class="n">n_pts_per_dim</span><span class="o">=</span><span class="n">n_pts_per_dim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">vis_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vls</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vls</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">pts</span><span class="p">)[:,</span> <span class="n">vis_dim</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">vls</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_pts_per_dim</span><span class="p">),</span> <span class="n">dim_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="standard_rgba_to_premultiplied"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.standard_rgba_to_premultiplied">[docs]</a><span class="k">def</span> <span class="nf">standard_rgba_to_premultiplied</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Converts between standard and pre-multiplied RGBA representations.</span>

<span class="sd">    Args:</span>
<span class="sd">        img: Input image in standard RGBA format of shape d_x*d_y*4</span>

<span class="sd">    Returns:</span>
<span class="sd">        Nothing.  The image is modified in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span></div>


<div class="viewcode-block" id="premultiplied_rgba_to_standard"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.premultiplied_rgba_to_standard">[docs]</a><span class="k">def</span> <span class="nf">premultiplied_rgba_to_standard</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Converts between pre-multiplied and standard RGBA representations.</span>

<span class="sd">    Args:</span>
<span class="sd">        img: Input image in pre-multiplied RGBA format of shape d_x*d_y*4</span>

<span class="sd">    Returns:</span>
<span class="sd">        img: Nothing.  The image is modified in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">alpha_mask</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">img</span><span class="p">[</span><span class="n">alpha_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">alpha_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="n">alpha</span><span class="p">[</span><span class="n">alpha_mask</span><span class="p">,:]</span></div>


<div class="viewcode-block" id="generate_mean_dot_image"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.generate_mean_dot_image">[docs]</a><span class="k">def</span> <span class="nf">generate_mean_dot_image</span><span class="p">(</span><span class="n">image_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dot_ctrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dot_vls</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                <span class="n">sa_lengths</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a 2-d or 3-d image of the mean of values in ellipsoids.</span>

<span class="sd">    Generates an image by associating an ellipsoid with a set of 2 or 3-d locations. Each of these locations</span>
<span class="sd">    has an associated value.  A pixel value in the final image is simply the average of all the values associated</span>
<span class="sd">    with ellipsoids that contain that pixel.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_shape: The shape of the image to generate. Must be of length 2 or 3.</span>

<span class="sd">        dot_ctrs: The location of each ellipsoid center.  dot_ctrs[i, :] is the location</span>
<span class="sd">        for dot i.</span>

<span class="sd">        dot_vls: The value to associate with the locations.  dot_vls[i] is associated with the location</span>
<span class="sd">        dot_ctrs[i, :]</span>

<span class="sd">        sa_lengths: The lengths of the semi-axes of the ellipsoids to generate. The value of sa_lengths[j] is the</span>
<span class="sd">        length for dimension j.  All values in sa_lengths must be odd.</span>

<span class="sd">    Returns:</span>
<span class="sd">        img: The generated image.  Any pixel outside of an ellipsoid will have a value of nan.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If image_shape is not of length 2 or 3.</span>
<span class="sd">        ValueError: If all values in sa_lengths are not odd</span>
<span class="sd">        ValueError: If any dot centers are outside of the dimensions of the image to be generated</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Put image shape and sa_lengths into arrays</span>
    <span class="n">image_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">sa_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sa_lengths</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="c1"># Run checks</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;image must be 2-d or 3-d&#39;</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sa_lengths</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sa_lengths must all be odd&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_ctrs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;One or more dot centers are negative and therefore outside of the image.&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_ctrs</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">image_shape</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;One or more dot centers exceed image shape values and are therefore outside of the image.&#39;</span><span class="p">))</span>

    <span class="c1"># Generate the basic ellipsoid we convolve throughout the image</span>
    <span class="n">base_e_coord_mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sa_lengths</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">base_e_coord_mats</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span><span class="o">/</span><span class="n">l</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">base_e_coord_mats</span><span class="p">,</span> <span class="n">sa_lengths</span><span class="p">)]</span>
    <span class="n">base_e_coord_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">base_e_coord_mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">base_e_coord_mats</span><span class="p">:</span>
        <span class="n">base_e_coord_sum</span> <span class="o">=</span> <span class="n">base_e_coord_sum</span> <span class="o">+</span> <span class="n">m</span>
    <span class="n">base_e_im</span> <span class="o">=</span> <span class="n">base_e_coord_sum</span> <span class="o">&lt;</span> <span class="mi">1</span>

    <span class="c1"># Generate the empty expanded arrays we need for generating the image</span>
    <span class="n">expanded_im_dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">image_shape</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sa_lengths</span><span class="p">)</span>
    <span class="n">expanded_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">expanded_im_dims</span><span class="p">)</span>
    <span class="n">expanded_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">expanded_im_dims</span><span class="p">)</span>

    <span class="c1"># Fill the expanded arrays (this is where convolution with the ellipsoid occurs)</span>
    <span class="n">rounded_dot_ctrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dot_ctrs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">rounded_shifted_dot_ctrs</span> <span class="o">=</span> <span class="n">rounded_dot_ctrs</span> <span class="o">+</span> <span class="n">sa_lengths</span>
    <span class="n">n_dots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dot_vls</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
        <span class="n">cur_ctr</span> <span class="o">=</span> <span class="n">rounded_shifted_dot_ctrs</span><span class="p">[</span><span class="n">d_i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">cur_vl</span> <span class="o">=</span> <span class="n">dot_vls</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span>
        <span class="n">cur_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cur_ctr</span><span class="p">,</span> <span class="n">sa_lengths</span><span class="p">))</span>

        <span class="n">expanded_cnts</span><span class="p">[</span><span class="n">cur_slice</span><span class="p">][</span><span class="n">base_e_im</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">expanded_im</span><span class="p">[</span><span class="n">cur_slice</span><span class="p">][</span><span class="n">base_e_im</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cur_vl</span>

    <span class="c1"># Produce the final image</span>
    <span class="n">expanded_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">expanded_im</span><span class="p">,</span> <span class="n">expanded_cnts</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">expanded_cnts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">expanded_im</span><span class="p">[</span><span class="n">expanded_cnts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">final_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="o">+</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">image_shape</span><span class="p">,</span> <span class="n">sa_lengths</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">expanded_im</span><span class="p">[</span><span class="n">final_slice</span><span class="p">]</span></div>


<div class="viewcode-block" id="generate_dot_image"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.generate_dot_image">[docs]</a><span class="k">def</span> <span class="nf">generate_dot_image</span><span class="p">(</span><span class="n">image_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">dot_ctrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dot_clrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">dot_diameter</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Generates an image of dots over a transparent background.</span>

<span class="sd">    All position/size units are in pixels.</span>

<span class="sd">    Dots are layered according to their order in dot_ctrs with dot_ctrs[0,:] on the bottom.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_shape: The [width, height] of the image in pixels</span>

<span class="sd">        dot_ctrs: dot_ctrs[i,:] gives the position of the center of the i^th dot</span>

<span class="sd">        dot_clrs: dot_clrs[i,:] gives the RGBA color of the i^th dot</span>

<span class="sd">        dot_diameter: The diameter of the dot to generate in pixel.  Must be an odd number.</span>

<span class="sd">    Returns:</span>
<span class="sd">        img: The generated image of shape [image_shape[0], image_shape[1], 4] where the last dimension is the RGBA</span>
<span class="sd">        value of each pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">img_w</span> <span class="o">=</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">img_h</span> <span class="o">=</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Run some checks</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dot_diameter</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dot_diameter must be an integer&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dot_diameter</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dot diameter must be an odd number&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">dot_ctrs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dot_ctrs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">img_w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All centers must be within image boundaries.&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">dot_ctrs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">dot_ctrs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">img_h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All centers must be within image boundaries.&#39;</span><span class="p">))</span>

    <span class="c1"># ==================================================================================================</span>
    <span class="c1"># Generate the mask of the template dot we will use</span>
    <span class="n">dot_img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">dot_diameter</span><span class="p">,</span> <span class="n">dot_diameter</span><span class="p">))</span>
    <span class="n">dot_drawer</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">dot_img</span><span class="p">)</span>
    <span class="n">dot_drawer</span><span class="o">.</span><span class="n">ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dot_diameter</span><span class="p">,</span> <span class="n">dot_diameter</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dot_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dot_img</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># ==================================================================================================</span>
    <span class="c1"># Place the dots</span>
    <span class="n">dot_ctrs_rnd</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dot_ctrs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="c1"># Pad the image we will construct to account for edge effects</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dot_diameter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dot_diameter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dot_diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="c1"># Premultiply alpha colors</span>
    <span class="n">dot_clrs_pm</span> <span class="o">=</span> <span class="n">dot_clrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dot_clrs_pm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_clrs_pm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">dot_clrs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">n_dots</span> <span class="o">=</span> <span class="n">dot_ctrs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>

        <span class="n">ctr_i</span> <span class="o">=</span> <span class="n">dot_ctrs_rnd</span><span class="p">[</span><span class="n">d_i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="n">dot_i</span> <span class="o">=</span> <span class="n">dot_mask</span><span class="o">*</span><span class="n">dot_clrs_pm</span><span class="p">[</span><span class="n">d_i</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">dot_slice_0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ctr_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ctr_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dot_slice_1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ctr_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ctr_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">alpha_composite</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">dot_slice_0</span><span class="p">,</span> <span class="n">dot_slice_1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dot_i</span><span class="p">)</span>

    <span class="c1"># ==================================================================================================</span>

    <span class="c1"># Convert to standard RGBA format</span>
    <span class="n">premultiplied_rgba_to_standard</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="c1"># Remove padding from the image</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">img</span></div>


<div class="viewcode-block" id="generate_dot_image_3d"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.generate_dot_image_3d">[docs]</a><span class="k">def</span> <span class="nf">generate_dot_image_3d</span><span class="p">(</span><span class="n">image_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dot_ctrs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dot_vls</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                          <span class="n">ellipse_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Generates a 3-d scalar image of ellipses, given the center location of each ellipse.</span>

<span class="sd">    All position/size units are in pixels.</span>

<span class="sd">    If two ellipses or more ellipses overlap, the value of the overlapping region is the average of the ellipse values.</span>

<span class="sd">    Any pixels in the generated image without an ellipse in them will have the value nan.</span>

<span class="sd">    Args:</span>
<span class="sd">        image_shape: The shape of the image to generate.</span>

<span class="sd">        dot_ctrs: dot_ctrs[i,:] is the center position of the i^th dot in pixels.  Dot centers will be rounded to the</span>
<span class="sd">        nearest whole pixel values before generating images of ellipses.</span>

<span class="sd">        dot_vls: dot_vls[i] is the value for the i^th ellipse</span>

<span class="sd">        ellipse_shape: ellipse_shape[d] gives the width of the generated ellipses in the d^th dimension.  All</span>
<span class="sd">        values in ellipse_shape must be odd.</span>

<span class="sd">    Returns:</span>
<span class="sd">        img: The generated image.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any of the dot centers are outside of the image.</span>
<span class="sd">        ValueError: If any value in ellipse_shape is not odd.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make sure all values in ellipse_shape are odd</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ellipse_shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All values in ellipse_shape must be odd.&#39;</span><span class="p">))</span>

    <span class="c1"># Make sure all the centers are in the bounds of the image</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_ctrs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All dot centers must be within the bounds of the image&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_ctrs</span> <span class="o">&gt;=</span> <span class="n">image_shape</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All dot centers must be within the bounds of the image&#39;</span><span class="p">))</span>

    <span class="c1"># Generate the mask we will use for the dot</span>
    <span class="n">ellipse_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ellipse_shape</span><span class="p">)</span>
    <span class="n">ellipse_widths</span> <span class="o">=</span> <span class="n">ellipse_shape</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">,</span> <span class="n">z_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ellipse_shape</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">ellipse_values</span> <span class="o">=</span> <span class="p">((</span><span class="n">x_grid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ellipse_widths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_grid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ellipse_widths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                      <span class="p">(</span><span class="n">z_grid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ellipse_widths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">ellipse_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ellipse_values</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Generate the image</span>
    <span class="n">dot_ctrs_rnd</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dot_ctrs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="c1"># Pad the arrays we need to construct to account for edge effects</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">image_shape</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">ellipse_shape</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
    <span class="n">cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">image_shape</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">ellipse_shape</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">ellipse_shape</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="n">n_dots</span> <span class="o">=</span> <span class="n">dot_ctrs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
        <span class="n">ctr_i</span> <span class="o">=</span> <span class="n">dot_ctrs_rnd</span><span class="p">[</span><span class="n">d_i</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">offsets</span>
        <span class="n">dot_i</span> <span class="o">=</span> <span class="n">dot_vls</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span><span class="o">*</span><span class="n">ellipse_mask</span>

        <span class="n">dot_slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="n">ctr_i</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">offsets</span><span class="p">[</span><span class="n">d_i</span><span class="p">],</span> <span class="n">ctr_i</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="n">d_i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">d_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

        <span class="n">w_sum</span><span class="p">[</span><span class="n">dot_slices</span><span class="p">][</span><span class="n">ellipse_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="n">dot_slices</span><span class="p">][</span><span class="n">ellipse_mask</span><span class="p">]</span> <span class="o">+</span> <span class="n">dot_i</span><span class="p">[</span><span class="n">ellipse_mask</span><span class="p">]</span>
        <span class="n">cnts</span><span class="p">[</span><span class="n">dot_slices</span><span class="p">][</span><span class="n">ellipse_mask</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Generate the final image</span>
    <span class="n">cnts_divide</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cnts</span><span class="p">)</span>
    <span class="n">cnts_divide</span><span class="p">[</span><span class="n">cnts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">w_sum</span><span class="o">/</span><span class="n">cnts_divide</span>
    <span class="n">img</span><span class="p">[</span><span class="n">cnts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Remove padding</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
              <span class="n">offsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">offsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">img</span></div>


<div class="viewcode-block" id="generate_image_from_fcn"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.generate_image_from_fcn">[docs]</a><span class="k">def</span> <span class="nf">generate_image_from_fcn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dim_sampling</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Generates a multi-d image from a function.</span>

<span class="sd">    The main use for this function is generating images for visualization.</span>

<span class="sd">    Args:</span>
<span class="sd">        f: The function to plot.</span>

<span class="sd">        dim_sampling: Each entry of dim_sampling specifies how to sample a dimension in the</span>
<span class="sd">        domain of the fuction.  Each entry is of the form [start, stop, int] where start and</span>
<span class="sd">        and stop are the start and stop of the range of values to sample from and int</span>
<span class="sd">        is the interval values are sampled from.</span>

<span class="sd">    Returns:</span>
<span class="sd">        im: The image</span>

<span class="sd">        coords: A list of coordinates along each dimension the function was sampled at.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Determine coordinates we will sample from along each dimension</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">dim_sampling</span><span class="p">]</span>
    <span class="n">n_coords_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>

    <span class="c1"># Form coordinates of each point we will sample from in a single numpy array</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">n_pts</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">flat_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">n_pts</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Evaluate the function</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">flat_grid</span><span class="p">)</span>

    <span class="c1"># Shape y into the appropriate image size</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_coords_per_dim</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">im</span><span class="p">,</span> <span class="n">coords</span><span class="p">]</span></div>


<div class="viewcode-block" id="generate_binary_color_rgba_image"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.generate_binary_color_rgba_image">[docs]</a><span class="k">def</span> <span class="nf">generate_binary_color_rgba_image</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">neg_clr</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">pos_clr</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Generates an RGBA image of two colors from a 2-d numpy array.</span>

<span class="sd">    Negative values will be one color while positive values will be another.</span>

<span class="sd">    The alpha channel will be equal to the absolute value of entries of a, so all values of a must be in [-1, 1].</span>

<span class="sd">    The negative color will be assigned to entries strictly less than 0, while the positive channel will be assigned</span>
<span class="sd">    to entries greater than or equal to 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: The array to binarize.</span>

<span class="sd">        neg_clr: A sequence of floats specifying the RGB values for the negative color.  All value should in [0, 1].</span>
<span class="sd">        If None, the negative color will be red.</span>

<span class="sd">        pos_clr: A sequence of floats specifying the RGB values for the positive color.  All value should in [0, 1].</span>
<span class="sd">        If None, the positive color will be green.</span>

<span class="sd">    Returns:</span>
<span class="sd">        im: The image of shape [a.shape[0], a.shape[1], 4]</span>

<span class="sd">    Raises:</span>
<span class="sd">         ValueError: If any entry in a is outside of [-1, 1]</span>
<span class="sd">         ValueError: If a is not a 2-d array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All values in a must be in the range [-1, 1].&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input a must be a 2-d array.&#39;</span><span class="p">))</span>

    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">neg_clr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neg_clr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">neg_clr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">neg_clr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pos_clr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pos_clr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_clr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pos_clr</span><span class="p">)</span>

    <span class="n">neg_vls</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="n">im</span><span class="p">[</span><span class="n">neg_vls</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_clr</span>

    <span class="n">pos_vls</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">im</span><span class="p">[</span><span class="n">pos_vls</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_clr</span>

    <span class="n">im</span><span class="p">[:,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im</span></div>


<div class="viewcode-block" id="max_project_pts"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.max_project_pts">[docs]</a><span class="k">def</span> <span class="nf">max_project_pts</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dot_vls</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">box_position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">n_divisions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dot_dim_width</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Assigns a radius to points in 2-d space to make dots.  Then generates an image of max dot values in a grid.</span>

<span class="sd">    The motivation for this function is that there are times when physical objects in space (such as neurons) have</span>
<span class="sd">    been represented as finite points.  In these cases, we might desire to visualize how physical properties associated</span>
<span class="sd">    with each object are distributed in space.  There are three challenges we face when doing this:</span>

<span class="sd">    1) How to visualize a point.  We solve this by adding a radius to the points to make dots.</span>

<span class="sd">    2) How to make sense of over-lapping dots.  We do this by taking a &quot;max projection&quot; of the dots - that is</span>
<span class="sd">    at each point in space, we keep the value associated with the largest magnitude (so sign doesn&#39;t matter).</span>

<span class="sd">    3) How to go from continuous space to discrete space, so we can make images.  We solve this by allowing the</span>
<span class="sd">    user to specify a grid, defining discrete points in space we want to calculate a value for.</span>

<span class="sd">    The final question we need to consider is what to do with points in space that have no dot in them?  In this</span>
<span class="sd">    case, we will return an nan value.</span>

<span class="sd">    Args:</span>
<span class="sd">        dot_positions: The positions of dots, each column is a dimension.  Values must be floating point.</span>

<span class="sd">        dot_vls: The values associated with each point.  A 1-d array.</span>

<span class="sd">        box_position: The position of a box we define the grid in.  box_position[0,0] is the start of the side for</span>
<span class="sd">        dimension 0 and box_position[1,0] is the end of the side for dimension 0.  box_position[:,1] contains the</span>
<span class="sd">        start and end of the side for dimension 1.</span>

<span class="sd">        n_divisions: The number of divisions to use for the grid.  n_divisions[i] is the number of divisions for</span>
<span class="sd">        dimension i.</span>

<span class="sd">        dot_dim_width: We allow dots to be ellipses.  dot_dim_width[i] is the width of a dot in dimension i.</span>

<span class="sd">    Returns:</span>
<span class="sd">        im: The final image, of shape n_divisions.</span>

<span class="sd">        inds: Same shape as im.  inds[i,j] is the index of the dot in dot_vls that the value of im[i,j] came from.</span>
<span class="sd">        Entries in im with nan values will also have nan values in inds.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If dot positions are not floating point.</span>
<span class="sd">        ValueError: If any dot position is outside of the boundaries of the box.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Run some checks</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dot_positions</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dot positions must be floating point numbers.&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dots must be contained within the box.&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dots must be contained within the box.&#39;</span><span class="p">))</span>

    <span class="n">box_width</span> <span class="o">=</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Transform points to a standard coordinate system, where lower left of box is at (0,0) and upper right is at (1,1)</span>
    <span class="n">dot_positions</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">)</span>
    <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">box_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">box_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">div_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">n_divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># Generate a template binary mask of a dot</span>
    <span class="n">dot_n_div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">dot_dim_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">box_width</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">div_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">dot_dim_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">box_width</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">div_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])</span>

    <span class="c1"># Make sure we have an odd number of divisions</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dot_n_div</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dot_n_div</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dot_n_div</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dot_n_div</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">dot_img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">dot_n_div</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dot_n_div</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">dot_drawer</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">dot_img</span><span class="p">)</span>
    <span class="n">dot_drawer</span><span class="o">.</span><span class="n">ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dot_n_div</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dot_n_div</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dot_img_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dot_img</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">dot_img_float</span> <span class="o">=</span> <span class="n">dot_img_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
    <span class="n">dot_img_float</span><span class="p">[</span><span class="n">dot_img</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Create the empty images of max values and indices - initially we add padding</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dot_n_div</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">n_divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_divisions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
    <span class="n">im</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">inds</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Now fill in the image</span>
    <span class="n">n_pts</span> <span class="o">=</span> <span class="n">dot_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pts</span><span class="p">):</span>
        <span class="c1"># Calculate center grid square for each dot</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dot_positions</span><span class="p">[</span><span class="n">p_i</span><span class="p">,:]</span><span class="o">/</span><span class="n">div_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="n">pad_width</span>
        <span class="n">dot_vl</span> <span class="o">=</span> <span class="n">dot_vls</span><span class="p">[</span><span class="n">p_i</span><span class="p">]</span>

        <span class="c1"># Calculate the selection coordinates for each grid</span>
        <span class="n">d0_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">d1_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Indices where we actually need to do a comparison</span>
        <span class="n">cmp_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dot_img_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">d0_slice</span><span class="p">,</span> <span class="n">d1_slice</span><span class="p">])))</span>

        <span class="c1"># See which of compare indices are set to dot values</span>
        <span class="n">keep_cmp_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dot_vl</span><span class="o">*</span><span class="n">dot_img_float</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">d0_slice</span><span class="p">,</span> <span class="n">d1_slice</span><span class="p">]),</span>
                                   <span class="n">where</span><span class="o">=</span><span class="n">cmp_inds</span><span class="p">)</span>

        <span class="c1"># See where we don&#39;t need to do a comparison</span>
        <span class="n">non_cmp_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dot_img_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">d0_slice</span><span class="p">,</span> <span class="n">d1_slice</span><span class="p">]))</span>

        <span class="c1"># Get set of all indices we are setting to dot value</span>
        <span class="n">set_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">keep_cmp_inds</span><span class="p">,</span> <span class="n">non_cmp_inds</span><span class="p">)</span>

        <span class="n">im</span><span class="p">[</span><span class="n">d0_slice</span><span class="p">,</span> <span class="n">d1_slice</span><span class="p">][</span><span class="n">set_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_vl</span>
        <span class="n">inds</span><span class="p">[</span><span class="n">d0_slice</span><span class="p">,</span> <span class="n">d1_slice</span><span class="p">][</span><span class="n">set_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_i</span>

    <span class="c1"># Now remove padding</span>
    <span class="n">d0_im_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">d1_im_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">non_padded_im</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">d0_im_slice</span><span class="p">,</span> <span class="n">d1_im_slice</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">non_padded_im</span><span class="p">,</span> <span class="n">inds</span><span class="p">]</span></div>


<div class="viewcode-block" id="rgb_3d_max_project"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.rgb_3d_max_project">[docs]</a><span class="k">def</span> <span class="nf">rgb_3d_max_project</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Computes 3d-max projection of RGB data.</span>

<span class="sd">    The computation is done by converting the image to gray scale, finding max values of the gray scale image,</span>
<span class="sd">    and the retaining the rgb information at these max values.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol: The volume to max project.  Should be of shape [dx, dy, dz, 3], with the last dimension holding RGB values.</span>

<span class="sd">        axis: The axis to project along</span>

<span class="sd">    Returns:</span>
<span class="sd">        proj: The projected image.  The first two dimensions will be the retained dimensions from the projection and</span>
<span class="sd">        the last dimension will be of length 3, holding RGB values.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the last dimension of vol is not of length 3.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;vol must be an RGB image.&#39;</span><span class="p">))</span>

    <span class="n">d_0</span><span class="p">,</span> <span class="n">d_1</span><span class="p">,</span> <span class="n">d_2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Convert rgb to gray scale using same formula as skimage.color.rgb2gray</span>
    <span class="n">gray_img</span> <span class="o">=</span> <span class="o">.</span><span class="mi">2125</span><span class="o">*</span><span class="n">vol</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">7154</span><span class="o">*</span><span class="n">vol</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">0721</span><span class="o">*</span><span class="n">vol</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Find the max along the requested axis</span>
    <span class="n">max_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gray_img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Return the projection</span>
    <span class="n">inds_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d_0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">inds_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">inds_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d_2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="n">inds_0</span> <span class="o">=</span> <span class="n">inds_0</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">inds_1</span> <span class="o">=</span> <span class="n">inds_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inds_1</span> <span class="o">=</span> <span class="n">inds_1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">inds_2</span> <span class="o">=</span> <span class="n">inds_2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">inds_sel</span> <span class="o">=</span> <span class="p">[</span><span class="n">inds_0</span><span class="p">,</span> <span class="n">inds_1</span><span class="p">,</span> <span class="n">inds_2</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
    <span class="n">inds_sel</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_inds</span>
    <span class="n">inds_sel</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inds_sel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vol</span><span class="p">[</span><span class="n">inds_sel</span><span class="p">]</span></div>


<div class="viewcode-block" id="scalar_3d_max_project"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.scalar_3d_max_project">[docs]</a><span class="k">def</span> <span class="nf">scalar_3d_max_project</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">abs_vl</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Computes 3d max projection of scalar data.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol: The volume to project.  Should be of shape [dx, dy, dz]</span>

<span class="sd">        axis: The dimension to project along</span>

<span class="sd">        abs_vl: True if values with the largest absolute value should be returned; if false, then values with the</span>
<span class="sd">        largest positive value will be returned.</span>

<span class="sd">    Returns:</span>
<span class="sd">        proj:  The projected image. Will be 2-d with a shape corresponding to the retained dimensions of vol.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If vol is not a 3d array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vol</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;vol must be a 3d array&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">abs_vl</span><span class="p">:</span>
        <span class="n">max_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vol</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">d_0</span><span class="p">,</span> <span class="n">d_1</span><span class="p">,</span> <span class="n">d_2</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Return the projection</span>
    <span class="n">inds_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d_0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">inds_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d_1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">inds_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d_2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">inds_0</span> <span class="o">=</span> <span class="n">inds_0</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">inds_1</span> <span class="o">=</span> <span class="n">inds_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inds_1</span> <span class="o">=</span> <span class="n">inds_1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">inds_2</span> <span class="o">=</span> <span class="n">inds_2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">inds_sel</span> <span class="o">=</span> <span class="p">[</span><span class="n">inds_0</span><span class="p">,</span> <span class="n">inds_1</span><span class="p">,</span> <span class="n">inds_2</span><span class="p">]</span>
    <span class="n">inds_sel</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_inds</span>
    <span class="n">inds_sel</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inds_sel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vol</span><span class="p">[</span><span class="n">inds_sel</span><span class="p">]</span></div>


<div class="viewcode-block" id="signed_max_project"><a class="viewcode-back" href="../../../autoapi/janelia_core/visualization/image_generation/index.html#janelia_core.visualization.image_generation.signed_max_project">[docs]</a><span class="k">def</span> <span class="nf">signed_max_project</span><span class="p">(</span><span class="n">volume</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Performs a signed max projection on 3-d data.</span>

<span class="sd">    Args:</span>
<span class="sd">        volume: The volume to do the max projection on</span>

<span class="sd">        axis: The axis to do the max projection along.</span>

<span class="sd">    Returns:</span>
<span class="sd">        im: The max projection image.  A 2-d array with dimensions inherited from volume.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If volume is not a 3d array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;volume must be a 3-d array.&#39;</span><span class="p">))</span>

    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">volume</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ret_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">m_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ret_shape</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">m_grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_grid</span><span class="p">]</span>
    <span class="n">m_grid</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span>
    <span class="n">m_grid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m_grid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">volume</span><span class="p">[</span><span class="n">m_grid</span><span class="p">]</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, William Bishop.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>