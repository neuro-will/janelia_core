:py:mod:`janelia_core.ml.latent_regression.group_maps`
======================================================

.. py:module:: janelia_core.ml.latent_regression.group_maps

.. autoapi-nested-parse::

   Objects for mapping input groups of variables to output groups of variables.

   The maps contained in this module are intended to serve as mappings in the latent spaces of latent regression
   models.

   William Bishop
   bishopw@hhmi.org



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   janelia_core.ml.latent_regression.group_maps.LinearMap
   janelia_core.ml.latent_regression.group_maps.NNMap
   janelia_core.ml.latent_regression.group_maps.IdentityMap
   janelia_core.ml.latent_regression.group_maps.ElementWiseTransformedGroupLatents
   janelia_core.ml.latent_regression.group_maps.GroupTransform
   janelia_core.ml.latent_regression.group_maps.GroupLinearTransform
   janelia_core.ml.latent_regression.group_maps.GroupMatrixMultiply
   janelia_core.ml.latent_regression.group_maps.ConcatenateMap
   janelia_core.ml.latent_regression.group_maps.ConcatenateAndSelectMap
   janelia_core.ml.latent_regression.group_maps.SingleGroupDenseNetMap




.. py:class:: LinearMap(d_in: Sequence, d_out: Sequence, bias=False)

   Bases: :py:obj:`torch.nn.Module`

   Wraps torch.nn.Linear for use with a latent mapping.

   All inputs are concatenated together before being passed through the mapping to form output.


   Creates a LinearMap object.

   Args:
       d_in: d_in[g] gives the dimensionality of input group g

       d_out: d_out[g] gives the dimensionality of output group g

       bias: True, if the linear mapping should include a bias.


   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Computes output given input.

      Args:
          x: Input.  x[g] gives the input for input group g as a tensor of shape n_smps*n_dims

      Returns:
          y: Output.  y[h] gives the output for output group h as a tensor or shape n_smps*n_dims



.. py:class:: NNMap(d_out: Sequence[int], nn: torch.nn.Module)

   Bases: :py:obj:`torch.nn.Module`

   Wraps a general neural network for use with a latent mapping.

   All inputs are concatenated together before being passed through the mapping to form output.

   The transformed output can then be partitioned to form different output groups.

   Args:
       d_out: d_out[h] gives the dimensionality of output group h.  Outputs are read in the order of groups.  So
       for example, the first d_out[0] outputs will be outputs for group 0, then next d_out[1] outputs for group
       1 and so on...

       nn: The neural network to wrap.  Should accept inputs of size equal to the concatenation of all input
       and produce outputs of the size of all concatenated output.

   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Computes output given input.

      Args:
          x: Input.  x[g] gives the input for input group g as a tensor of shape n_smps*n_dims

      Returns:
          y: Output.  y[h] gives the output for output group h as a tensor or shape n_smps*n_dims



.. py:class:: IdentityMap

   Bases: :py:obj:`torch.nn.Module`

   Identity latent mapping.

   Creates an IdentityMap object.

   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Passes through input as output.

      Args:
          x: Input.  x[g] gives the input for input group g as a tensor of shape n_smps*n_dims

      Returns:
          y: Output.  y[g] gives the output for output group h as a tensor or shape n_smps*n_dims



.. py:class:: ElementWiseTransformedGroupLatents(f: torch.nn.Module)

   Bases: :py:obj:`torch.nn.Module`

   Output is formed by applying a function elementwise to input for each group.

   Creates an ElementWiseTransformedGroupLatents object.

   Args:
       f: The function to apply to each element of output for each group.

   .. py:method:: forward(self, x: torch.Tensor) -> torch.Tensor

      Computes output from input.



.. py:class:: GroupTransform(transforms: Sequence[torch.nn.Module])

   Bases: :py:obj:`torch.nn.Module`

   Applies a different transformation to groups of input, producing output for each group.




   Creates a new GroupTransform object.

   Args:
       transforms: A list of transforms to apply. transforms[i] is the transform that will be applied to intut
       group i

   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Computes input from output.



.. py:class:: GroupLinearTransform(d: Sequence[int], offsets: bool = True, nonnegative_scale: bool = False, v_mn: float = 0.0, v_std: float = 0.1, o_mn: float = 0.0, o_std: float = 0.1)

   Bases: :py:obj:`torch.nn.Module`

   Forms output by multiplying each entry in group input vectors by a separate scalar and adding an offset.

   Offsets can also optionally be omitted and the absolute value of the scale parameters can be used to enforce that
   scaling is always non-negative.


   Creates a GroupScalarTransform object.

   Args:
      d: d[i] gives the dimensionality of group i

      offsets: True if offsets should also be included.

      nonnegative_scale: True if when applying scales, the absolute value of scale parameters should be used.

      v_mn, v_std: The mean and standard deviation for initializing the slope of the linear mappings

      o_mn, o_std: The mean and standard deviations for initializing the offsets of the linear mappings

   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      " Computes output given input.

      Args:
          x: Input. x[g] gives the input for group g as a tensor of shape n_smps*n_dims

      Returns:
          y: Output. y[g] gives the output for group g as a tensor of shampe n_smps*n_dims




.. py:class:: GroupMatrixMultiply(d_in: Sequence[int], d_out: Sequence[int], w_gain: float = 1.0)

   Bases: :py:obj:`torch.nn.Module`

   Mapping which applies a matrix multiply seperately to each input vector to form output vectors.

   Creates a GroupMatrixMultiply object.

   Args:
       d_in: d_in[i] gives the input dimension of group i

       d_out: d_out[i] gives the output dimension of group i

       w_gain: Gain to apply when initializing matrix weights


   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Computes output given input.

      Args:
          x: Input. x[g] gives the input for group g as a tensor of shape n_smps*n_dims

      Returns:
          y: Output. y[g] gives the output for group g as a tensor of shampe n_smps*n_dims



.. py:class:: ConcatenateMap(conc_grps: numpy.ndarray)

   Bases: :py:obj:`torch.nn.Module`

   Mapping which concatenates input to form output.

   Concatenation follows the order of input groups.

   Creates a ConcatenateMap object.

   Args:
       conc_grps: A binary array.  conc_grps[h, :] is a vector indicating which groups of projected
       latents should be concatenated to form output for tran_h.

   Raises:
       ValueError: If dtype of conc_grps is not bool


   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Concatents input to form output.



.. py:class:: ConcatenateAndSelectMap(d_in: Sequence[int], output_inds: Sequence[Sequence[torch.Tensor]])

   Bases: :py:obj:`torch.nn.Module`

   Concatenates input from all input groups and then selects entries of the result for different output groups.


   Creates a ConcatenateAndSelectMap object.

   Args:
       d_in: d_in[g] is the dimensionality of the g^th input group

       output_inds: output_inds[h][g] is a torch tensor of dtype long indicating which entries of
       the g^th input group should be in the h^th output group.  The output of each group will be formed
       by concatenating the included entries for all input groups.  The order of concatenating groups follows
       the order of the input groups. The value None indicates no entries from input g should be selected.


   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> Sequence[torch.Tensor]

      Forms output from input.

      Args:
          x: x[g] is the input for the g^th group of shape n_smps*d_g

      Returns:
          y: y[h] is the output for the h^th group of shape n_smps*d_h



.. py:class:: SingleGroupDenseNetMap(d_in: int, d_out: int, n_layers: int, growth_rate: int, bias: bool = True)

   Bases: :py:obj:`torch.nn.Module`

   Maps from one group of input to one group of output using a dense net.

   Creates a new SingleGroupDenseNetMap object.

   The dense net will use Tanh non-linearities.

   Args:
       d_in: The input dimensionality to the map

       d_out: The output dimensionality to the map

       n_layers: The number of layers in the dense net

       growth_rate: The growth rate of the dense net

       bool: True if the dense net should have bias terms

   .. py:method:: forward(self, x: Sequence[torch.Tensor]) -> List[torch.Tensor]

      Computes input from output.

      Args:
          x: x[0] is the input for the single group of shape n_smps*d_in

      Returns:
          y: y[0] is the output of shape n_smps*d_out



